
//RIAStudio client runtime widget - DGrid

define([
	"rias",
	"rias/riasw/layout/Panel",
	"rias/riasw/mobile/Button",
	"dgrid/List",
	"dgrid/Grid",
	"dgrid/OnDemandGrid",
	//"dgrid/Grid",
	//"dgrid/_StoreMixin",
	"dgrid/CellSelection",
	"dgrid/ColumnSet",
	"dgrid/Editor",
	"dgrid/GridFromHtml",
	"dgrid/GridWithColumnSetsFromHtml",
	"dgrid/Keyboard",
	"dgrid/Selection",
	"dgrid/Selector",
	"dgrid/Tree",
	"dgrid/util/misc",
	'dojo/has!touch?dgrid/util/touch',
	"dgrid/extensions/ColumnHider",
	"dgrid/extensions/ColumnResizer",
	"dgrid/extensions/ColumnReorder",
	"dgrid/extensions/CompoundColumns",
	"dgrid/extensions/DijitRegistry",
	"dgrid/extensions/Dnd",
	"dgrid/extensions/Pagination",
	"dstore/Trackable",
	"dstore/legacy/StoreAdapter",
	"dstore/QueryResults",
	"dstore/Tree"
], function(rias, Panel, Button, List, Grid,//getGridXRiasd,
			_Widget, CellSelection, ColumnSet, Editor,
			GridFromHtml, GridWithColumnSetsFromHtml, Keyboard, Selection, Selector, Tree,
			misc, touchUtil,
			ColumnHider, ColumnResizer, ColumnReorder, CompoundColumns, DijitRegistry, Dnd, Pagination,
			Trackable, StoreAdapter, QueryResults, StoreTree) {

	var _WidgetBase = rias.getObject("dijit._WidgetBase");
	var autoId = 0;
	function generateId() {
		return "riaswDGrid_" + autoId++;
	}

	rias.theme.loadRiasCss([
		"grid/dgrid/dgrid.css",
		"grid/dgrid/dgridskin.css"
	], false, function(){
		rias.theme.addCssRule('.dgrid-scrollbar-width', 'width: ' + rias.theme.scrollbarWidth + 'px');
		rias.theme.addCssRule('.dgrid-scrollbar-height', 'height: ' + rias.theme.scrollbarHeight + 'px');

		if (rias.theme.scrollbarWidth !== 17) {
			// for modern browsers, we can perform a one-time operation which adds
			// a rule to account for scrollbar width in all grid headers.
			rias.theme.addCssRule('.dgrid-header-row', 'right: ' + rias.theme.scrollbarWidth + 'px');
			// add another for RTL grids
			rias.theme.addCssRule('.dgrid-rtl-swap .dgrid-header-row', 'left: ' + rias.theme.scrollbarWidth + 'px');
		}
	});

	List.extend({

		postscript: function(/*Object?*/params, /*DomNode|String*/srcNodeRef){
			var grid = this;

			(this._Row = function (id, object, element) {
				this.id = id;
				this.data = object;
				this.element = element;
			}).prototype.remove = function () {
				grid.removeRow(this.element);
			};

			if (srcNodeRef) {
				// normalize srcNodeRef and store on instance during create process.
				// Doing this in postscript is a bit earlier than dijit would do it,
				// but allows subclasses to access it pre-normalized during create.
				this.srcNodeRef = srcNodeRef = srcNodeRef.nodeType ? srcNodeRef : byId(srcNodeRef);
			}

			/// inherited _WidgetBase
			this.inherited(arguments);
		},
		create: function (params, srcNodeRef) {
			this._introspect();

			this.ownerDocument = this.ownerDocument || (srcNodeRef ? srcNodeRef.ownerDocument : rias.dom.doc);
			this.ownerDocumentBody = rias.dom.documentBody(this.ownerDocument);
			var domNode = this.domNode = srcNodeRef || rias.dom.create('div'),
				cls;

			if (params) {
				this.params = params;
				rias.safeMixin(this, params);
				//rias.mixin(this, params);

				// Check for initial class or className in params or on domNode
				cls = params['class'] || params.className || domNode.className;
			}

			// ensure arrays and hashes are initialized
			this.sort = this.sort || [];
			this._listeners = [];
			this._rowIdToObject = {};

			this.postMixInProperties && this.postMixInProperties();

			// Apply id to widget and domNode,
			// from incoming node, widget params, or autogenerated.
			this.id = domNode.id = domNode.id || this.id || generateId();
			rias.registry.add(this);

			// Perform initial rendering, and apply classes if any were specified.
			this.buildRendering();
			if (cls) {
				//setClass.call(this, cls);
				rias.dom.replaceClass(this.domNode, cls, this._class || '');
				// Store for later retrieval/removal.
				this._class = cls;
			}

			this._applyAttributes();///需要在 buildRendering 之后。
			this.postCreate(params);

			// remove srcNodeRef instance property post-create
			//delete this.srcNodeRef;

			this._created = true;

			// to preserve "it just works" behavior, call startup if we're visible
			if (this.domNode.offsetHeight) {
				this.startup();
			}
		},
		buildRendering: function () {
			var domNode = this.domNode,
				addUiClasses = this.addUiClasses,
				self = this,
				headerNode,
				bodyNode,
				footerNode,
				isRTL;

			// Detect RTL on html/body nodes; taken from dojo/dom-geometry
			isRTL = this.isRTL = (rias.dom.body.dir || rias.dom.doc.documentElement.dir ||
				rias.dom.body.style.direction).toLowerCase() === 'rtl';

			// Clear out className (any pre-applied classes will be re-applied via the
			// class / className setter), then apply standard classes/attributes
			domNode.className = '';

			domNode.setAttribute('role', 'grid');
			rias.dom.addClass(domNode, 'dgrid dgrid-' + this.listType + (addUiClasses ? ' ui-widget' : ''));

			///增加 topTools
			if(this.topTools){
				rias.dom.place(this.topTools.domNode, domNode, "first");
				rias.dom.addClass(this.topTools.domNode, 'dgrid-header dgrid-header-tools' + (addUiClasses ? ' ui-widget-header' : ''));
			}
			// Place header node (initially hidden if showHeader is false).
			headerNode = this.headerNode = rias.dom.create('div', {
				className: 'dgrid-header dgrid-header-row' + (addUiClasses ? ' ui-widget-header' : '') +
					(this.showHeader ? '' : ' dgrid-header-hidden')
			}, domNode);

			bodyNode = this.bodyNode = rias.dom.create('div', {
				className: 'dgrid-scroller'
			}, domNode);

			// Firefox 4+ adds overflow: auto elements to the tab index by default;
			// force them to not be tabbable, but restrict this to Firefox,
			// since it breaks accessibility support in other browsers
			if (rias.has('ff')) {
				bodyNode.tabIndex = -1;
			}

			this.headerScrollNode = rias.dom.create('div', {
				className: 'dgrid-header dgrid-header-scroll dgrid-scrollbar-width' +
					(addUiClasses ? ' ui-widget-header' : '')
			}, domNode);

			// Place footer node (initially hidden if showFooter is false).
			footerNode = this.footerNode = rias.dom.create('div', {
				className: 'dgrid-footer' + (this.showFooter ? '' : ' dgrid-footer-hidden')
			}, domNode);

			if (isRTL) {
				domNode.className += ' dgrid-rtl' +
					(rias.has('dom-rtl-scrollbar-left') ? ' dgrid-rtl-swap' : '');
			}

			this.own(rias.on(bodyNode, 'scroll', function (event) {
				if (self.showHeader) {
					// keep the header aligned with the body
					headerNode.scrollLeft = event.scrollLeft || bodyNode.scrollLeft;
				}
				// re-fire, since browsers are not consistent about propagation here
				event.stopPropagation();
				rias.on.emit(domNode, 'scroll', {scrollTarget: bodyNode});
			}));
			this.configStructure();
			this.renderHeader();

			this.contentNode = this.touchNode = rias.dom.create('div', {
				className: 'dgrid-content' + (addUiClasses ? ' ui-widget-content' : '')
			}, this.bodyNode);

			// add window resize handler, with reference for later removal if needed
			this._listeners.push(this._resizeHandle = rias.dom.Viewport.on("resize", misc.throttleDelayed(function(){
				if (this._started) {
					this.resize();
				}
			}, this)));

			if (this.baseClass) {
				var classes = this.baseClass.split(" ");
				if (!this.isLeftToRight()) {
					classes = classes.concat(rias.map(classes, function (name) {
						return name + "Rtl";
					}));
				}
				rias.dom.addClass(this.domNode, classes);
			}

			// Note: for dojo 2.0 may rename widgetId to dojo._scopeName + "_widgetId"
			this.domNode.setAttribute('widgetId', this.id);
		},
		postCreate: function () {
			this.inherited(arguments);
		},
		startup: function () {
			if (this._started) {
				return;
			}
			/// inherited _WidgetBase
			this.inherited(arguments);
			this._started = true;
			// apply sort (and refresh) now that we're ready to render
			this.set('sort', this.sort);
			var widget = this.getParent();
			// If we have a parent layout container widget, it will handle resize,
			// so remove the window resize listener added by List.
			if (widget && widget.isLayoutContainer) {
				this._resizeHandle.remove();
			}
			this.resize();
		},
		destroy: function (preserveDom) {
			if(this.topTools){
				rias.destroy(this.topTools);
			}
			// Remove any event listeners and other such removables
			if (this._listeners) { // Guard against accidental subsequent calls to destroy
				for (var i = this._listeners.length; i--;) {
					this._listeners[i].remove();
				}
				this._listeners = null;
			}

			/// inherited _WidgetBase
			this.inherited(arguments);

			this._started = false;
			this.cleanup();

			// destroy DOM
			//rias.dom.destroy(this.domNode);
		},

		get: function (/*String*/ name /*, ... */) {
			var fn = '_get' + name.charAt(0).toUpperCase() + name.slice(1);

			if (typeof this[fn] === 'function') {
				return this[fn].apply(this, [].slice.call(arguments, 1));
			}

			if (!rias.has('dojo-built') && typeof this[fn + 'Attr'] === 'function') {
				console.warn('dgrid: Use ' + fn + ' instead of ' + fn + 'Attr for getting ' + name);
			}

			///允许使用 _getXXXAttr
			return this.inherited(arguments);
		},
		set: function (/*String*/ name, /*Object*/ value /*, ... */) {
			if (typeof name === 'object') {
				for (var k in name) {
					this.set(k, name[k]);
				}
			}else {
				var fn = '_set' + name.charAt(0).toUpperCase() + name.slice(1);

				if (typeof this[fn] === 'function') {
					this[fn].apply(this, [].slice.call(arguments, 1));
				}else {
					if (!rias.has('dojo-built') && typeof this[fn + 'Attr'] === 'function') {
						console.warn('dgrid: Use ' + fn + ' instead of ' + fn + 'Attr for setting ' + name);
					}

					///允许使用 _setXXXAttr
					this.inherited(arguments);
				}
			}

			return this;
		},

		resize: function () {
			var bodyNode = this.bodyNode,
				headerNode = this.headerNode,
				footerNode = this.footerNode,
				headerHeight = headerNode.offsetHeight,
				footerHeight = this.showFooter ? footerNode.offsetHeight : 0;

			this.headerScrollNode.style.top = (this.topTools ? this.topTools.domNode.offsetHeight : 0) + "px";
			this.headerScrollNode.style.height = headerHeight + "px";
			bodyNode.style.marginTop = (this.topTools ? headerHeight + this.topTools.domNode.offsetHeight : headerHeight) + 'px';
			bodyNode.style.marginBottom = footerHeight + 'px';
		}

	});

	Selection.extend({
		postCreate: function () {
			var self = this;
			this.inherited(arguments);
			this.own(rias.on(rias.webApp.domNode, "dgrid-select", function(evt){
				self.onSelect(evt);
			}), rias.on(rias.webApp.domNode, "dgrid-deselect", function(evt){
				self.onDeselect(evt);
			}));
			this._initSelectionEvents();

			// Force selectionMode setter to run
			var selectionMode = this.selectionMode;
			this.selectionMode = '';
			this._setSelectionMode(selectionMode);
		},
		onSelect: function(evt){
		},
		onDeselect: function(evt){
		},
		getSelectedIds: function(){
			var result = [],
				selection = this.selection, p;
			for(p in selection){
				if(selection[p]){
					result.push(p);
				}
			}
			return result;
		}
	});

	ColumnResizer.extend({
		_configColumn: function (column) {
			this.inherited(arguments);

			var colId = column.id,
				rule;

			///允许 column.width 为 string
			if ('width' in column) {
				// Update or add a style rule for the specified width
				if ((rule = this._oldColumnSizes[colId])) {
					rule.set('width', column.width + 'px');
				}else {
					rule = misc.addCssRule('#' + misc.escapeCssIdentifier(this.domNode.id) +
						' .dgrid-column-' + misc.escapeCssIdentifier(colId, '-'),
						'width: ' + (rias.isNumber(column.width) ? column.width + 'px;' : column.width + ';'));
				}
				this._columnSizes[colId] = rule;
			}
		}
	});

	Tree.extend({
		_destroyColumns: function () {
			this.inherited(arguments);
			var listeners = this._treeColumnListeners;

			for (var i = listeners.length; i--;) {
				listeners[i].remove();
			}
			this._treeColumnListeners = [];

			///begin================================///
			///需要重置，以能够重新处理（生成） treeColumn
			///reset somethings
			if(this._treeColumn){
				this._treeColumn._isConfiguredTreeColumn = undefined;
				this._treeColumn.renderCell = this._originalRenderCell;
			}
			this._originalRenderCell = undefined;
			///end=================================///

			this._treeColumn = null;
		},

		_configureTreeColumn: function (column) {
			// summary:
			//		Adds tree navigation capability to a column.
			if (column._isConfiguredTreeColumn) {
				return;
			}

			var originalRenderCell = column.renderCell || this._defaultRenderCell;
			///begin================================///
			///保存，以在 _destroyColumns 中重置
			///save the original renderCell call
			column._originalRenderCell = originalRenderCell;
			///end=================================///

			column._isConfiguredTreeColumn = true;
			column.renderCell = function (object, value, td, options) {
				// summary:
				//		Renders a cell that can be expanded, creating more rows

				var grid = this.grid,
					level = Number(options && options.queryLevel) + 1,
					mayHaveChildren = !grid.collection.mayHaveChildren || grid.collection.mayHaveChildren(object),
					expando, node;

				level = grid._currentLevel = isNaN(level) ? 0 : level;
				expando = this.renderExpando(level, mayHaveChildren,
					grid._expanded[grid.collection.getIdentity(object)], object);
				expando.level = level;
				expando.mayHaveChildren = mayHaveChildren;

				node = originalRenderCell.call(this, object, value, td, options);
				if (node && node.nodeType) {
					td.appendChild(expando);
					td.appendChild(node);
				}
				else {
					td.insertBefore(expando, td.firstChild);
				}
			};

			var clicked; // tracks row that was clicked (for expand dblclick event handling)

			this._treeColumn = column;

			var grid = this,
				colSelector = '.dgrid-content .dgrid-column-' + column.id;

			if (typeof column.renderExpando !== 'function') {
				column.renderExpando = this._defaultRenderExpando;
			}

			// Set up the event listener once and use event delegation for better memory use.
			this._treeColumnListeners.push(this.on(column.expandOn ||
				'.dgrid-expando-icon:click,' + colSelector + ':dblclick,' + colSelector + ':keydown',
				function (event) {
					var row = grid.row(event);
					if ((!grid.collection.mayHaveChildren || grid.collection.mayHaveChildren(row.data))
						&& (event.type !== 'keydown' || event.keyCode === 32)
						&& !(event.type === 'dblclick' && clicked && clicked.count > 1 && row.id === clicked.id
							&& event.target.className.indexOf('dgrid-expando-icon') > -1)) {
						clicked && clicked.count++;///FIX#1255
						grid.expand(row);
					}

					// If the expando icon was clicked, update clicked object to prevent
					// potential over-triggering on dblclick (all tested browsers but IE < 9).
					if (event.target.className.indexOf('dgrid-expando-icon') > -1) {
						if (clicked && clicked.id === grid.row(event).id) {
							clicked.count++;
						}
						else {
							clicked = {
								id: grid.row(event).id,
								count: 1
							};
						}
					}
				})
			);

			if (rias.has('touch')) {
				// Also listen on double-taps of the cell.
				this._treeColumnListeners.push(this.on(touchUtil.selector(colSelector, touchUtil.dbltap),
					function () {
						grid.expand(this);
					}));
			}

		}

	});

	function appendIfNode(parent, subNode) {
		if (subNode && subNode.nodeType) {
			parent.appendChild(subNode);
		}
	}
	Grid.extend({
		_createBodyRowCell: function (cellElement, column, item, options) {
			var cellData = item;

			// Support get function or field property (similar to DataGrid)
			if (column.get) {
				cellData = column.get(item);
			}else if ('field' in column && column.field !== '_item') {
				cellData = item[column.field];
			}

			if(column.style){
				if(cellElement.style.cssText){
					cellElement.style.cssText += "; " + rias.dom.styleToString(column.style);
				}else{
					cellElement.style.cssText = rias.dom.styleToString(column.style);
				}
			}
			if (column.renderCell) {
				// A column can provide a renderCell method to do its own DOM manipulation,
				// event handling, etc.
				appendIfNode(cellElement, column.renderCell(item, cellData, cellElement, options));
			}else {
				this._defaultRenderCell.call(column, item, cellData, cellElement, options);
			}
		},

		resize: function (changeSize, resultSize) {
			if(this._riasrDestroying || this._beingDestroyed){
				return;
			}
			var v,
				box;
			if(!this._started){
				this._needResize = true;
				this._changeSize = rias.mixin(this._changeSize, changeSize);
				this._resultSize = rias.mixin(this._resultSize, resultSize);
				return;
			}
			this._wasResized = true;
			box = resultSize || {};

			box = rias.mixin(this._changeSize, changeSize, box);
			this._changeSize = undefined;
			this._resultSize = undefined;
			rias.dom.setMarginBox(this.domNode, box);
			//box = rias.dom.getMarginBox(node);

			this.inherited(arguments);

			// extension of List.resize to allow accounting for
			// column sizes larger than actual grid area
			var headerTableNode = this.headerNode.firstChild,
				contentNode = this.contentNode,
				width;
			// Force contentNode width to match up with header width.
			contentNode.style.width = ''; // reset first
			if (contentNode && headerTableNode) {
				if ((width = headerTableNode.offsetWidth) > contentNode.offsetWidth) {
					// update size of content node if necessary (to match size of rows)
					// (if headerTableNode can't be found, there isn't much we can do)
					contentNode.style.width = width + 'px';
				}
			}

		}
	});
	var _DStoreAdapter = rias.declare([StoreAdapter],{//, StoreTree], {
		constructor: function () {
			this.root = this;
		},
		mayHaveChildren: function (object) {
			//return 'hasChildren' in object ? object.hasChildren : true;
			return this.root.objectStore.hasChildren && this.root.objectStore.hasChildren(this.getIdentity(object), object);
		},
		getRootCollection: function () {
			//return this.root.filter({ parent: null });
			return this.root.filter({ parentId: null });
		},
		getChildren: function (object) {
			//return this.root.filter({ parent: this.getIdentity(object) });
			return this.root.filter({ parentId: this.getIdentity(object) });
		},

		fetchRange: function (rangeArgs) {
			// summary:
			//		Fetches the query results with a range. Note that the fetch may occur asynchronously
			// returns: Array|Promise
			//		The results or a promise for the results

			// create an object store query and query options based on current collection
			// information
			var queryOptions = {},
				queryLog = this.queryLog,
				getQueryArguments = function (type) {
					return rias.map(
						rias.filter(queryLog, function (entry) {
							return entry.type === type;
						}),
						function (entry) {
							return entry.normalizedArguments[0];
						}
					);
				};

			// take the last sort since multiple sorts are not supported by dojo/store
			var sorted = getQueryArguments('sort').pop();
			if (sorted) {
				queryOptions.sort = sorted;

				if (sorted instanceof Array) {
					// object stores expect an attribute property
					for (var i = 0; i < sorted.length; i++) {
						var sortSegment = sorted[i];
						sortSegment.attribute = sortSegment.property;
					}
				}
			}
			if (rangeArgs) {
				// set the range
				queryOptions.count = rangeArgs.end - ((queryOptions.start = rangeArgs.start) || 0);
			}

			///增加 this.queryObject，可以传递给 store.query
			var queryObject = rias.delegate(this.queryObject) || {};
			applyFilter(getQueryArguments('filter'));

			function applyFilter(filtered) {
				for (var i = 0; i < filtered.length; i++) {
					var filter = filtered[i];
					var type = filter.type;
					var args = filter.args;
					if (type === 'and') {
						applyFilter(args);
					} else if (type === 'eq' || type === 'match') {
						queryObject[args[0]] = args[1];
					} else if (type === 'string') {
						queryObject = args[0];
					} else if (type) {
						throw new Error('"' + type + ' operator can not be converted to a legacy store query');
					}
					// else if (!type) { no-op }
				}
			}

			var results = this.objectStore.query(queryObject, queryOptions);
			if (results) {
				// apply the object restoration
				return new QueryResults(rias.when(results.map(this._restore, this)), {
					totalLength: rias.when(results.total)
				});
			}
			return rias.when(results);
		}
	});
	var riasType = "rias.riasw.grid.DGrid";
	var Widget = rias.declare(riasType, [_WidgetBase, _Widget, ColumnResizer, ColumnHider, ColumnReorder,// ColumnSet, Pagination,
		Keyboard, Selection, Selector, Editor, Tree], {

		_setCollection: function (collection) {
			if(!collection.fetchRange){
				collection = new _DStoreAdapter({
					idAttribute: collection.idAttribute,
					labelAttribute: collection.labelAttribute,
					objectStore: collection,
					queryObject: collection.queryObject
				});
			}
			if(!collection.track){
				collection = Trackable.create(collection);
			}
			if(!collection.idAttribute){
				collection.idAttribute = "id";
			}
			if(!collection.labelAttribute){
				collection.labelAttribute = "label";
			}
			this.inherited(arguments);
		},
		refresh: function(query){
			if(query){
				this._queryObject0 = query;
			}
			this.collection.queryObject = rias.delegate(this._queryObject0);
			this.inherited(arguments);
		}
	});

	function columnFormatter(cellData, data){
		var col = this,
			field = col.field,
			format = col.format,
			v;
		if(data[field] === undefined){
			return data[field];
		}
		try{
			if(rias.isFunction(format)){
				return format.apply(col, [cellData, data]);
			}else if(rias.isString(format)){
				switch(format){
					case "text":
						return data[field];
					case "date":
						return rias.datetime.format(data[field], rias.datetime.defaultDateFormatStr);
					case "time":
						return rias.datetime.format(data[field], rias.datetime.defaultTimeFormatStr);
					case "datetime":
						return rias.datetime.format(data[field], rias.datetime.defaultFormatStr);
					case "boolean":
						return (data[field] != false ? "是" : "否");
					default:
						if(/^number/.test(format)){
							v = data[field];
							return rias.toFixed(v, rias.toInt(format.substring(6), 0));
						}
						return data[field];
				}
			}
		}catch(e){
			return e;
		}
	}
	Widget._riasdMeta = {
		visual: true,
		iconClass: "riaswGridIcon",
		iconClass16: "riaswGridIcon16",
		defaultParams: function(params){
			var p = rias.mixinDeep({}, params),
				i, l, n, b,
				treeColumns = (rias.isArray(p.treeColumns) ? p.treeColumns : rias.isString(p.treeColumns) ? [p.treeColumns] : []),
				opColumn = [], gridOps = [], item;

			if(!p._riaswIdOfModule){
				p._riaswIdOfModule = "grid";
			}

			function _column(arr){
				rias.forEach(arr, function(item){
					if(rias.isArray(item)){
						_column(item);
					}else{
						if(!item.label){
							if(item.name){
								item.label = item.name;
								delete item.name;
							}
						}
						if(treeColumns.indexOf(item.field) >= 0){
							item.renderExpando = true;
						}
						if(item.format && !item.formatter){
							item.formatter = function(cellData, data){
								return columnFormatter.apply(this, arguments);
							}
						}
					}
				});
			}
			if(!p.columns){
				if(p.structure){
					p.columns = p.structure;
					_column(p.columns);
				}else{
					p.columns = [];
				}
			}
			delete p.structure;
			delete p.treeColumns;

			if(!p.collection){
				if(rias.isRiasw(p.store)){
					p.collection = p.store;
				}else if(rias.isObjectSimple(p.store)){
					p.collection = rias.mixinDeep({
						_riaswType: p.target ? "rias.riasw.store.JsonRestStore" : "rias.riasw.store.MemoryStore",
						_riaswIdOfModule: p._riaswIdOfModule + "_store",
						idAttribute: 'id',
						labelAttribute: 'label'
					}, p.store);
				}else{
					p.collection = {
						_riaswType: p.target ? "rias.riasw.store.JsonRestStore" : "rias.riasw.store.MemoryStore",
						_riaswIdOfModule: p._riaswIdOfModule + "_store",
						idAttribute: 'id',
						labelAttribute: 'label'
					};
				}
				if(treeColumns.length > 0){
					p.collection.isTreeStore = true;
				}
			}
			if(p.target){
				p.collection.target = p.target;
			}
			delete p.store;
			p._queryObject0 = p.query;
			if(!p.collection.queryObject && p._queryObject0){
				p.collection.queryObject = p._queryObject0;
			}
			delete p.query;

			if(rias.isArray(p.cellIdOps)){
				opColumn = opColumn.concat(p.cellIdOps);
			}
			delete p.cellIdOps;
			function _getOpColumn(){
				return {
					label: rias.i18n.action.action,
					field: "id",
					"className": "dgrid-opcolumn",
					width: p.opColumnWidth || "6em",
					renderCell: function(data, cellData, cell, options){
						var result,
							grid = this.grid,
							module = grid._riasrModule,
							item, i, l;
						for(i = 0, l = opColumn.length; i < l; i++){
							item = opColumn[i];
							if(item && item.name){
								/*item = new Button({
									//_riaswType: "rias.riasw.form.Button",
									ownerRiasw: grid,
									//"class": "dgrid-selector-btn",
									name: item.name,
									label: item.text,
									tooltip: item.tooltip,
									onClick: function(){
										console.debug("click:" + this.label, data.id);
									}
								});
								item = item.domNode;*/
								item = rias.dom.create("button", {
									"class": "mblButton",
									name: item.name,
									title: item.tooltip,
									innerHTML: item.text,
									click: function(evt){
										//console.debug("click:" + this.name, data.id);
										var func = this.opParams.func;
										if(!func || func == "cellIdOnClick"){
											grid.cellIdOnClick.apply(grid, [grid, this.name, cell, data]);
										}else if(rias.isFunction(func)){
											func.apply(module, [grid, this.name, cell, data]);
										}else if(rias.isString(func) && rias.isFunction(module[func])){
											module[func].apply(module, [grid, this.name, cell, data]);
										}else{
											console.warn("error cell.item.onClick function of [" + this.name + "]");
										}
									}
								});
								item.opParams = opColumn[i];
								if(item && item.name){
									if(item.visible === undefined || item.visible == true ||
										(rias.isFunction(item.visible) && item.visible.apply(module, [grid, item.name, cell, data]))){
										if(item.disabled === true || (rias.isFunction(item.disabled) && item.disabled.apply(module, [grid, item.name, cell, data]))){
											rias.dom.setAttr(item, "disabled", true);
											rias.dom.setAttr(item, "aria-disabled", true);
										}
									}else{
										rias.dom.visible(item, false);
									}
								}
								cell["_op_" + item.name] = item;
								cell.appendChild(item);
							}
						}
					}
				};
			}
			if(opColumn.length > 0){
				if(rias.isObjectExact(p.columns)){
					p.columns = rias.mixin({
						"": _getOpColumn()
					}, p.columns);
				}else if(rias.isArray(p.columns)){
					p.columns.unshift(_getOpColumn());
				}else{
					p.columns = [_getOpColumn()];
				}
			}
			delete p.opColumnWidth;
			p.cellIdOnClick = function(grid, name, cell, data){
				var id = data[grid.collection.idAttribute],
					d = (data[grid.collection.labelAttribute] ? "[" + data[grid.collection.labelAttribute] + "]" : ""),
					params = cell["_op_" + name].opParams,
					meta = {
						dialogType: "top",
						ownerRiasw: grid,
						around: cell,
						orient: ["after-centered", "below", "above", "before"],
						moduleMeta: grid.viewModule,
						resizable: false,
						//restrictPadding: 0,
						//maxable: false,
						query: {
							id: id
						},
						initData: grid.opInitData,
						op: name,
						afterFiler: function(result){
							var m = this;
							if (rias.isFunction(m._riaswModuleMeta.afterFiler)){
								m._riaswModuleMeta.afterFiler.call(m, result);
							}
						},
						onSubmit: function(){
							var m = this,
								def = rias.newDeferred();
							grid.refresh();
							def.resolve(1);
							return def.promise;
						}
					};
				if(name == "modi"){
					rias.show(rias.mixinDeep({
						_riaswIdOfModule: grid._riaswIdOfModule + "_modiDlg_" + id,
						caption: params.tooltip + id + d,
						actionBar: [
							"btnSave",
							"btnCancel"
						],
						disabled: false,
						readOnly: false
					}, meta, params.moduleParams));
				}else if(name == "copy"){
					rias.show(rias.mixinDeep({
						_riaswIdOfModule: grid._riaswIdOfModule + "_copyDlg_" + id,
						caption: params.tooltip + id + d,
						actionBar: [
							"btnSave",
							"btnCancel"
						],
						disabled: false,
						readOnly: false
					}, meta, params.moduleParams));
				}else{
					rias.show(rias.mixinDeep({
						_riaswIdOfModule: grid._riaswIdOfModule + "_viewDlg_" + id,
						caption: params.tooltip + id + d,
						actionBar: [
							"btnClose"
						],
						disabled: true,
						readOnly: true
					}, meta, params.moduleParams));
				}
			};

			if(!p.selectionMode){
				if(p.selectRowTriggerOnCell == false){
					p.selectionMode = "none";
				}else{
					if(p.selectRowMultiple == true){
						p.selectionMode = "toggle";
					}else{
						p.selectionMode = "single";
					}
				}
			}
			delete p.selectRowTriggerOnCell;
			delete p.selectRowMultiple;
			function _getSelector(){
				return {
					label: "",
					field: "id",
					width: "2em",
					selector: (p.selectionMode === "single" ? "radio" : "checkbox")
				};
			}
			if(p.selectionMode !== "none"){
				if(rias.isObjectExact(p.columns)){
					p.columns = rias.mixin({
						"": _getSelector()
					}, p.columns);
				}else if(rias.isArray(p.columns)){
					p.columns.unshift(_getSelector());
				}else{
					p.columns = [_getSelector()];
				}
			}
			p.deselectOnRefresh = rias.ifnull(p.deselectOnRefresh, false);

			var _btnRefresh = {
					_riaswType: "rias.riasw.form.Button",
					_riaswIdOfModule: p._riaswIdOfModule + "_btnRefresh",
					grid: {
						$refObj: p._riaswIdOfModule
					},
					label: rias.i18n.action.refresh,
					tooltip: rias.i18n.action.refresh,
					iconClass: "refreshIcon",
					onClick: function(evt){
						this.grid.refresh();
					}
				},
				_btnAdd = {
					_riaswType: "rias.riasw.form.Button",
					_riaswIdOfModule: p._riaswIdOfModule + "_btnAdd",
					grid: {
						$refObj: p._riaswIdOfModule
					},
					label: rias.i18n.action.add,
					tooltip: rias.i18n.action.add,
					iconClass: "addIcon",
					onClick: function(evt){
						this.grid.addRecord(this.grid, this);
					}
				},
				_btnDele = {
					_riaswType: "rias.riasw.form.Button",
					_riaswIdOfModule: p._riaswIdOfModule + "_btnDele",
					grid: {
						$refObj: p._riaswIdOfModule
					},
					label: rias.i18n.action.dele,
					tooltip: rias.i18n.action.dele,
					iconClass: "deleIcon",
					onClick: function(evt){
						this.grid.deleRecoreds(this.grid, this.grid.getSelectedIds(), this);
					}
				};
			if(p.topBtns){
				gridOps = gridOps.concat([_btnRefresh], p.topBtns);
				delete p.topBtns;
			}
			if(gridOps.length > 0){
				p.topTools = {
					_riaswType: "rias.riasw.layout.Panel",
					_riaswIdOfModule: p._riaswIdOfModule + "_topTools",
					_riaswChildren: []
				};
				for(i = 0, l = gridOps.length; i < l; i++){
					item = gridOps[i];
					if(rias.isObjectSimple(item)){
						item = rias.mixinDeep({}, item.name === "btnAdd" ? _btnAdd : item.name === "btnDele" ? _btnDele : {
							_riaswType: "rias.riasw.form.Button",
							//_riaswIdOfModule: "btnCancel",
							//label: rias.i18n.action.cancel,
							//tooltip: rias.i18n.action.cancel,
							//iconClass: "cancelIcon",
							onClick: function(evt){
							}
						}, item);
					}else if(rias.isString(item)){
						if(item == "btnAdd"){
							item = _btnAdd;
						}else if(item == "btnDele"){
							item = _btnDele;
						}
					//}else{
					//	if(!rias.isDijit(item) && !rias.isRiasd(item)){
					//		item = undefined;
					//	}
					}
					if(item){
						p.topTools._riaswChildren.push(item);
					}
				}
			}
			p.addRecord = function(grid, around){
				rias.show({
					ownerRiasw: grid,
					_riaswIdOfModule: grid._riaswIdOfModule + "_addDlg",
					moduleMeta: grid.viewModule,
					dialogType: "modal",
					around: around,
					autoClose: 0,
					caption: rias.i18n.action.add,
					query: {
						//id: ""
					},
					initData: grid.opInitData,
					op: "add",
					actionBar: [
						"btnSave",
						"btnCancel"
					],
					//afterFiler: function(result){
					//	var m = this;
					//	if (rias.isFunction(m._riaswModuleMeta.afterFiler)){
					//		m._riaswModuleMeta.afterFiler.call(m, result);
					//	}
					//},
					onSubmit: function(){
						var d = rias.newDeferred();
						grid.refresh();
						d.resolve(1);
						return d.promise;
					}
				});
			};
			p.deleRecoreds = function(grid, ids, around){
				ids = (rias.isArray(ids) ? ids : rias.isString(ids) ? [ids] : []);
				if(ids.length){
					rias.choice({
						_riaswIdOfModule: grid._riaswIdOfModule + "_deleDlg",
						ownerRiasw: grid,
						dialogType: "modal",
						around: around,
						autoClose: 0,
						content: "是否删除[" + ids + "]?",
						caption: rias.i18n.action.dele,
						onSubmit: function(mr){
							//if(mr){
							rias.xhrDelete(grid.target, {
									_idDirty: ids.join(",")//[101, 10101, 010102]
								}, function(result){
									if(!result.success || result.success < 1){
										rias.warn("删除失败...");
									}else{
										grid.refresh();
									}
								}
							);
							//}
							return 1;
						}
					});
				}
			};

			p = rias.mixinDeep({
				indent: 1,
				inline: true,
				listType: "grid",
				cellNavigation: true,
				tabableHeader: true,
				showHeader: true,
				showFooter: true,

				minRowsPerPage: 50,
				maxRowsPerPage: 150,
				maxEmptySpace: Infinity,
				bufferRows: 25,
				farOffRemoval: 2000,
				queryRowsOverlap: 0,
				pagingMethod: 'debounce',
				pagingDelay: 15,
				keepScrollPosition: false,
				rowHeight: 0,

				collection: null,
				loadingMessage: ""
			}, p);
			return p;
		},
		initialSize: {},
		"property": {
		}
	};

	rias.on(rias.webApp.domNode, "dgrid-error", function(evt){
		evt.preventDefault(); // Suppress console.error
		console.error("document received dgrid-error: " + evt.error, evt);
	});

	return Widget;

});