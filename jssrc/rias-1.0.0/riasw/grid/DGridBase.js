
//RIAStudio client runtime widget - DGrid

define([
	"rias",

	"dgrid/util/misc",
	'dojo/has!touch?dgrid/util/touch',
	"dgrid/List",
	"dgrid/Grid",
	"dgrid/OnDemandList",
	"dgrid/OnDemandGrid",
	"dgrid/CellSelection",
	"dgrid/ColumnSet",
	"dgrid/Editor",
	"dgrid/Keyboard",
	"dgrid/Selection",
	"dgrid/Selector",
	"dgrid/Tree",
	//"dgrid/GridFromHtml",
	//"dgrid/GridWithColumnSetsFromHtml",
	"dgrid/extensions/ColumnHider",
	"dgrid/extensions/ColumnResizer",
	"dgrid/extensions/ColumnReorder",
	"dgrid/extensions/CompoundColumns",
	"dgrid/extensions/DijitRegistry",
	"dgrid/extensions/Dnd",
	"dgrid/extensions/Pagination"

], function(rias,
            misc, touchUtil,
            List, Grid, OnDemandList, OnDemandGrid, CellSelection, ColumnSet, Editor, Keyboard, Selection, Selector, Tree,
			//GridFromHtml, GridWithColumnSetsFromHtml,
			ColumnHider, ColumnResizer, ColumnReorder, CompoundColumns, DijitRegistry, Dnd, Pagination) {

	var _WidgetBase = rias.getObject("dijit._WidgetBase");
	var autoId = 0;
	function generateId() {
		return "riaswDGrid_" + autoId++;
	}

	rias.theme.loadRiasCss([
		"grid/dgrid/dgrid.css",
		"grid/dgrid/dgridskin.css"
	], false, function(){
		rias.theme.addCssRule('.dgrid-scrollbar-width', 'width: ' + rias.theme.scrollbarWidth + 'px');
		rias.theme.addCssRule('.dgrid-scrollbar-height', 'height: ' + rias.theme.scrollbarHeight + 'px');

		if (rias.theme.scrollbarWidth !== 17) {
			// for modern browsers, we can perform a one-time operation which adds
			// a rule to account for scrollbar width in all grid headers.
			rias.theme.addCssRule('.dgrid-header-row', 'right: ' + rias.theme.scrollbarWidth + 'px');
			// add another for RTL grids
			rias.theme.addCssRule('.dgrid-rtl-swap .dgrid-header-row', 'left: ' + rias.theme.scrollbarWidth + 'px');
		}
	});

	misc.addCssRule = function(selector, css){
		return rias.theme.addCssRule(selector, css);
	};

	List.extend({

		postscript: function(/*Object?*/params, /*DomNode|String*/srcNodeRef){
			var grid = this;

			(this._Row = function (id, object, element) {
				this.id = id;
				this.data = object;
				this.element = element;
			}).prototype.remove = function () {
				grid.removeRow(this.element);
			};

			if (srcNodeRef) {
				// normalize srcNodeRef and store on instance during create process.
				// Doing this in postscript is a bit earlier than dijit would do it,
				// but allows subclasses to access it pre-normalized during create.
				this.srcNodeRef = srcNodeRef = srcNodeRef.nodeType ? srcNodeRef : byId(srcNodeRef);
			}

			/// inherited _WidgetBase
			this.inherited(arguments);
		},
		create: function (params, srcNodeRef) {
			this._introspect();

			this.ownerDocument = this.ownerDocument || (srcNodeRef ? srcNodeRef.ownerDocument : rias.dom.doc);
			this.ownerDocumentBody = rias.dom.documentBody(this.ownerDocument);
			var domNode = this.domNode = srcNodeRef || rias.dom.create('div'),
				cls;

			if (params) {
				this.params = params;
				rias.safeMixin(this, params);
				//rias.mixin(this, params);

				// Check for initial class or className in params or on domNode
				cls = params['class'] || params.className || domNode.className;
			}

			// ensure arrays and hashes are initialized
			this.sort = this.sort || [];
			this._listeners = [];
			this._rowIdToObject = {};

			this.postMixInProperties && this.postMixInProperties();

			// Apply id to widget and domNode,
			// from incoming node, widget params, or autogenerated.
			this.id = domNode.id = domNode.id || this.id || generateId();
			rias.registry.add(this);

			// Perform initial rendering, and apply classes if any were specified.
			this.buildRendering();
			if (cls) {
				//setClass.call(this, cls);
				rias.dom.replaceClass(this.domNode, cls, this._class || '');
				// Store for later retrieval/removal.
				this._class = cls;
			}

			//this._applyAttributes();///需要在 buildRendering 之后。
			this.postCreate(params);

			// remove srcNodeRef instance property post-create
			//delete this.srcNodeRef;

			this._created = true;

			// to preserve "it just works" behavior, call startup if we're visible
			if (this.domNode.offsetHeight) {
				this.startup();
			}
		},
		buildRendering: function () {
			var domNode = this.domNode,
				addUiClasses = this.addUiClasses,
				self = this,
				headerNode,
				bodyNode,
				footerNode,
				isRTL;

			// Detect RTL on html/body nodes; taken from dojo/dom-geometry
			isRTL = this.isRTL = (rias.dom.body.dir || rias.dom.doc.documentElement.dir ||
				rias.dom.body.style.direction).toLowerCase() === 'rtl';

			// Clear out className (any pre-applied classes will be re-applied via the
			// class / className setter), then apply standard classes/attributes
			domNode.className = '';

			domNode.setAttribute('role', 'grid');
			rias.dom.addClass(domNode, 'dgrid dgrid-' + this.listType + (addUiClasses ? ' ui-widget' : ''));

			///增加 topTools
			if(this.topTools){
				rias.dom.place(this.topTools.domNode, domNode, "first");
				rias.dom.addClass(this.topTools.domNode, 'dgrid-header dgrid-header-tools' + (addUiClasses ? ' ui-widget-header' : ''));
			}
			// Place header node (initially hidden if showHeader is false).
			headerNode = this.headerNode = rias.dom.create('div', {
				className: 'dgrid-header dgrid-header-row' + (addUiClasses ? ' ui-widget-header' : '') +
					(this.showHeader ? '' : ' dgrid-header-hidden')
			}, domNode);

			bodyNode = this.bodyNode = rias.dom.create('div', {
				className: 'dgrid-scroller'
			}, domNode);

			// Firefox 4+ adds overflow: auto elements to the tab index by default;
			// force them to not be tabbable, but restrict this to Firefox,
			// since it breaks accessibility support in other browsers
			if (rias.has('ff')) {
				bodyNode.tabIndex = -1;
			}

			this.headerScrollNode = rias.dom.create('div', {
				className: 'dgrid-header dgrid-header-scroll dgrid-scrollbar-width' +
					(addUiClasses ? ' ui-widget-header' : '')
			}, domNode);

			// Place footer node (initially hidden if showFooter is false).
			footerNode = this.footerNode = rias.dom.create('div', {
				className: 'dgrid-footer' + (this.showFooter ? '' : ' dgrid-footer-hidden')
			}, domNode);

			if (isRTL) {
				domNode.className += ' dgrid-rtl' +
					(rias.has('dom-rtl-scrollbar-left') ? ' dgrid-rtl-swap' : '');
			}

			this.own(rias.on(bodyNode, 'scroll', function (event) {
				if (self.showHeader) {
					// keep the header aligned with the body
					headerNode.scrollLeft = event.scrollLeft || bodyNode.scrollLeft;
				}
				// re-fire, since browsers are not consistent about propagation here
				event.stopPropagation();
				rias.on.emit(domNode, 'scroll', {scrollTarget: bodyNode});
			}));
			this.configStructure();
			this.renderHeader();

			this.contentNode = this.touchNode = rias.dom.create('div', {
				className: 'dgrid-content' + (addUiClasses ? ' ui-widget-content' : '')
			}, this.bodyNode);

			// add window resize handler, with reference for later removal if needed
			this._listeners.push(this._resizeHandle = rias.dom.Viewport.on("resize", misc.throttleDelayed(function(){
				if (this._started) {
					this.resize();
				}
			}, this)));

			if (this.baseClass) {
				var classes = this.baseClass.split(" ");
				if (!this.isLeftToRight()) {
					classes = classes.concat(rias.map(classes, function (name) {
						return name + "Rtl";
					}));
				}
				rias.dom.addClass(this.domNode, classes);
			}

			// Note: for dojo 2.0 may rename widgetId to dojo._scopeName + "_widgetId"
			this.domNode.setAttribute('widgetId', this.id);
		},
		postCreate: function () {
			this.inherited(arguments);
		},
		startup: function () {
			if (this._started) {
				return;
			}
			/// inherited _WidgetBase
			this.inherited(arguments);
			this._started = true;
			// apply sort (and refresh) now that we're ready to render
			this.set('sort', this.sort);
			var widget = this.getParent();
			// If we have a parent layout container widget, it will handle resize,
			// so remove the window resize listener added by List.
			if (widget && widget.isLayoutContainer) {
				this._resizeHandle.remove();
			}
			this.resize();
		},
		destroy: function (preserveDom) {
			if(this.topTools){
				rias.destroy(this.topTools);
			}
			// Remove any event listeners and other such removables
			if (this._listeners) { // Guard against accidental subsequent calls to destroy
				for (var i = this._listeners.length; i--;) {
					this._listeners[i].remove();
				}
				this._listeners = null;
			}

			/// inherited _WidgetBase
			this.inherited(arguments);

			this._started = false;
			this.cleanup();

			// destroy DOM
			//rias.dom.destroy(this.domNode);
		},

		get: function (/*String*/ name /*, ... */) {
			var fn = '_get' + name.charAt(0).toUpperCase() + name.slice(1);

			if (typeof this[fn] === 'function') {
				return this[fn].apply(this, [].slice.call(arguments, 1));
			}

			///允许使用 _getXXXAttr
			//if (!rias.has('dojo-built') && typeof this[fn + 'Attr'] === 'function') {
			//	console.warn('dgrid: Use ' + fn + ' instead of ' + fn + 'Attr for getting ' + name);
			//}
			return this.inherited(arguments);
		},
		set: function (/*String*/ name, /*Object*/ value /*, ... */) {
			if (typeof name === 'object') {
				for (var k in name) {
					this.set(k, name[k]);
				}
			}else {
				var fn = '_set' + name.charAt(0).toUpperCase() + name.slice(1);

				if (typeof this[fn] === 'function') {
					this[fn].apply(this, [].slice.call(arguments, 1));
				}else {
					///允许使用 _setXXXAttr
					//if (!rias.has('dojo-built') && typeof this[fn + 'Attr'] === 'function') {
					//	console.warn('dgrid: Use ' + fn + ' instead of ' + fn + 'Attr for setting ' + name);
					//}
					this.inherited(arguments);
				}
			}

			return this;
		},

		_internalResize: function(box){
			console.debug(this.id, box);
			rias.dom.setMarginBox(this.domNode, box);
			//box = rias.dom.getMarginBox(node);
			return box;
		},
		resize: function (changeSize, resultSize) {
			if(this._riasrDestroying || this._beingDestroyed){
				return;
			}
			var v,
				box;
			v = this._started && this.get("visible");
			if(!v){
				//this._needResize = true;
				this._changeSize = rias.mixin(this._changeSize, changeSize);
				this._resultSize = rias.mixin(this._resultSize, resultSize);
				return;
			}
			this._wasResized = true;
			box = resultSize || {};

			box = rias.mixin(this._changeSize, changeSize, box);
			this._changeSize = undefined;
			this._resultSize = undefined;

			box = this._internalResize(box);
			//this._needResize = undefined;

			var bodyNode = this.bodyNode,
				headerNode = this.headerNode,
				footerNode = this.footerNode,
				headerHeight = headerNode.offsetHeight,
				footerHeight = this.showFooter ? footerNode.offsetHeight : 0;

			this.headerScrollNode.style.top = (this.topTools ? this.topTools.domNode.offsetHeight : 0) + "px";
			this.headerScrollNode.style.height = headerHeight + "px";
			bodyNode.style.height = (this.domNode.clientHeight - rias.theme.scrollbarHeight
				- (this.topTools ? headerHeight + this.topTools.domNode.offsetHeight : headerHeight) - footerHeight) + 'px';
			bodyNode.style.marginTop = (this.topTools ? headerHeight + this.topTools.domNode.offsetHeight : headerHeight) + 'px';
			bodyNode.style.marginBottom = footerHeight + 'px';

			return box;
		},

		renderArray: function (results, beforeNode, options) {
			// summary:
			//		Renders an array of objects as rows, before the given node.

			options = options || {};
			var self = this,
				start = options.start || 0,
				rowsFragment = rias.dom.doc.createDocumentFragment(),
				rows = [],
				container,
				i = 0,
				len = results.length;

			if (!beforeNode) {
				this._lastCollection = results;
			}

			// Insert a row for each item into the document fragment
			while (i < len) {
				///增加 options.rowNum
				options.rowNum = start + 1;
				rows[i] = this.insertRow(results[i], rowsFragment, null, start++, options);
				i++;
			}

			// Insert the document fragment into the appropriate position
			container = beforeNode ? beforeNode.parentNode : self.contentNode;
			if (container && container.parentNode &&
				(container !== self.contentNode || len)) {
				container.insertBefore(rowsFragment, beforeNode || null);
				if (len) {
					self.adjustRowIndices(rows[len - 1]);
				}
			}

			return rows;
		}

	});

	var colsetidAttr = 'data-dgrid-column-set-id';

	function getColumnSetSubRows(subRows, columnSetId, startRow) {
		// Builds a subRow collection that only contains columns that correspond to
		// a given column set id.
		if (!subRows || !subRows.length) {
			return;
		}
		var subset = [],
			idPrefix = columnSetId + '-',
			i = startRow || 0,
			numRows = subRows.length;
		for (; i < numRows; i++) {
			var row = subRows[i];
			var subsetRow = [];
			subsetRow.className = row.className;
			for (var k = 0, numCols = row.length; k < numCols; k++) {
				var column = row[k];
				// The column id begins with the column set id.
				if (column.id != null && column.id.indexOf(idPrefix) === 0) {
					column.columnSetId = columnSetId;
					subsetRow.push(column);
				}
			}
			subset.push(subsetRow);
		}
		return subset;
	}
	ColumnSet.extend({
		postMixInProperties: function(){
			///增加 this._columnSetRules 判断
			this._columnSetRules = {};
			///增加 this._columnSizes 判断，this._columnSizes 在多个地方使用、创建。
			if(!this._columnSizes){
				this._columnSizes = {};
			}
			this.inherited(arguments);
		},
		/// 需要使用 this.own(aspect.after)
		/*postCreate: function () {
			var self = this;
			this.inherited(arguments);

			this.on(horizMouseWheel(this), horizMoveHandler);
			if (has('touch')) {
				this.on(horizTouchMove(this), horizMoveHandler);
			}

			this.on('.dgrid-column-set:dgrid-cellfocusin', function (event) {
				self._onColumnSetCellFocus(event, this);
			});

			if (typeof this.expand === 'function') {
				aspect.after(this, 'expand', function (promise, args) {
					promise.then(function () {
						var row = self.row(args[0]);
						if (self._expanded[row.id]) {
							// scrollLeft changes can't take effect on collapsed child rows;
							// ensure they are properly updated once re-expanded.
							adjustScrollLeft(self, row.element.connected);
						}
					});
					return promise;
				});
			}
		},*/
		startup: function(){
			///增加 onColumnResize
			var self = this;
			if (this._started) {
				return;
			}
			/// inherited _WidgetBase
			this.inherited(arguments);
			this._started = true;

			this.own(rias.on(this.domNode, "dgrid-columnresize", function(evt){
				self._calColumnSet();
			}));
		},
		destroy: function () {
			this.inherited(arguments);

			///增加 this._columnSizes
			var name;
			for (name in this._columnSizes) {
				this._columnSizes[name].remove();
			}
			///增加 this._columnSetRules
			for (name in this._columnSetRules) {
				this._columnSetRules[name].remove();
			}
			this._columnSetScrollerNode = undefined;
		},

		styleColumnSet: function (colsetId, css, /*String*/parentCss) {
			// summary:
			//		Dynamically creates a stylesheet rule to alter a columnset's style.

			///增加 this._columnSetRules
			parentCss = parentCss || "";
			var sId = colsetId + parentCss,
				rule = this._columnSetRules[sId];
			if (rule) {
				rule.set(css);
			}else{
				rule = this.addCssRule('#' + misc.escapeCssIdentifier(this.domNode.id) + " " + parentCss + ' .dgrid-column-set-' + misc.escapeCssIdentifier(colsetId, '-'), css);
				this._columnSetRules[sId] = rule;
			}
			if(this._columnSetScrollers){
				this._positionScrollers();
			}
			return rule;
		},
		/*createRowCells: function (tag, each, subRows, object, options) {
			var row = rias.dom.create('table', { className: 'dgrid-row-table' });
			var tbody = rias.dom.create('tbody', null, row);
			var tr = rias.dom.create('tr', null, tbody);
			for (var i = 0, l = this.columnSets.length; i < l; i++) {
				// iterate through the columnSets
				var cell = rias.dom.create(tag, {
					className: 'dgrid-column-set-cell dgrid-column-set-' + i
				}, tr);
				cell = rias.dom.create('div', {
					className: 'dgrid-column-set'
				}, cell);
				cell.setAttribute(colsetidAttr, i);
				var subset = getColumnSetSubRows(subRows || this.subRows, i) || this.columnSets[i];
				cell.appendChild(this.inherited(arguments, [tag, each, subset, object, options]));
			}
			return row;
		},*/
		renderHeader: function () {
			// summary:
			//		Setup the headers for the grid
			this.inherited(arguments);

			var columnSets = this.columnSets,
				scrollers = this._columnSetScrollers,
				grid = this;

			function reposition() {
				grid._positionScrollers();
			}

			this._columnSetScrollerContents = {};
			this._columnSetScrollLefts = {};

			if (scrollers) {
				// this isn't the first time; destroy existing scroller nodes first
				for (i in scrollers) {
					rias.dom.destroy(scrollers[i]);
				}
			} else {
				// first-time-only operations: hook up event/aspected handlers
				///增加 this.own
				this.own(
					rias.after(this, 'resize', reposition, true),
					rias.after(this, 'styleColumn', reposition, true)
				);
				this._columnSetScrollerNode = rias.dom.create('div', {
					className: 'dgrid-column-set-scroller-container'
				}, this.footerNode, 'after');
			}

			// reset to new object to be populated in loop below
			scrollers = this._columnSetScrollers = {};

			for (i = 0, l = columnSets.length; i < l; i++) {
				this._putScroller(columnSets[i], i);
			}

			this._positionScrollers();
		},

		_calColumnSet: function(){
			function _getsw(node, sw){
				var w = 0;
				if(sw.indexOf("em") >= 0){
					rias.theme.testElement(node, function(el){
						w += (parseFloat(sw) * rias.dom.getPadExtents(el).t);
					});
				}else{
					w += parseFloat(sw);
				}
				return rias.dom.box2marginBox(node, {w: w}).w;
			}
			var self = this,
				cols, col, colw, w, s,// ws,
				i, l, rule;
			for (i = 0, l = this.columnSets.length - 1; i < l; i++) {
				///最后一个 columnSets 不能设置
				if(this.columnSetWidths && this.columnSetWidths[i]){
					this.styleColumnSet(i, {
						width: rias.isNumber(this.columnSetWidths[i]) ? this.columnSetWidths[i] + "px" : this.columnSetWidths[i]
					});
				}else{
					cols = getColumnSetSubRows(this.subRows && this.subRows.headerRows, i) || this.columnSets[i];
					w = 20;
					rias.forEach(cols[0], function(column, idx){
						if (rule = self._columnSizes[column.id]) {
							colw = rule.get("width");
							colw = _getsw(column.headerNode, colw);
						}else {
							colw = 0;
							s = (rias.dom.styleToObject(column.headerNode.style).width) || column.width;
							if(s){
								colw = _getsw(column.headerNode, s);
							}else if(column._riasrOpColumn){
								rias.forEach(column._riasrOpColumn, function(item){
									colw += _getsw(column.headerNode, (item.text + " ").length + "em");
								});
							}else{
								colw = rias.dom.getMarginBox(column.headerNode).w;
							}
							rule = self.addCssRule('#' + misc.escapeCssIdentifier(self.domNode.id) +
								' .dgrid-column-' + misc.escapeCssIdentifier(column.id, '-'),
								'width: ' + rias.dom.marginBox2box(column.headerNode, {w: colw}).w + 'px;');
							self._columnSizes[column.id] = rule;
						}
						w += colw;
					});
					this.styleColumnSet(i, {
						width: w + "px"
					});
				}
			}
		},
		_internalResize: function(box){
			box = this.inherited(arguments);
			this._calColumnSet();
			return box;
		},

		_setColumnSets: function (columnSets) {
			this._destroyColumns();
			this.columnSets = columnSets;
			var scrolls = this._columnSetScrollLefts;
			this._updateColumns();
			if(this.keepScrollPosition){
				for(var id in scrolls){
					if(scrolls[id]){
						this._scrollColumnSet(id, scrolls[id]);
					}
				}
			}
		},
		_onColumnSetCellFocus: function (event, columnSetNode) {
			var focusedNode = event.target;
			/// 排除 resize-handle
			if(focusedNode.className.indexOf("dgrid-resize-handle") >= 0){
				return;
			}
			var columnSetId = columnSetNode.getAttribute(colsetidAttr),
				// columnSetNode's offsetLeft is not always correct,
				// so get the columnScroller to check offsetLeft against
				columnScroller = this._columnSetScrollers[columnSetId],
				elementEdge = focusedNode.offsetLeft - columnScroller.scrollLeft + focusedNode.offsetWidth;

			if (elementEdge > columnSetNode.offsetWidth || columnScroller.scrollLeft > focusedNode.offsetLeft) {
				this._scrollColumnSet(columnSetNode, focusedNode.offsetLeft);
			}
		}

	});

	ColumnReorder.extend({
		postCreate: function () {
			var self = this;

			this.inherited(arguments);

			///增加 onColumnReorder
			this.own(rias.on(this.domNode, "dgrid-columnreorder", function(evt){
				return self.onColumnReorder(evt) != false;
			}));
		},
		onColumnReorder: function(evt){
		},
		renderHeader: function () {
			function makeDndTypePrefix(gridId) {
				return 'dgrid-' + gridId + '-';
			}
			var dndTypePrefix = makeDndTypePrefix(this.id),
				csLength, cs;

			this.inherited(arguments);

			// After header is rendered, set up a dnd source on each of its subrows.

			this._columnDndSources = [];

			/// 保持与 Grid.renderHeader 和 _createHeaderRowCell 一致，
			/// 增加使用 this.subRows.headerRows
			if (this.columnSets) {
				// Iterate columnsets->subrows->columns.
				if(this.subRows && this.subRows.headerRows){
					for (cs = 0, csLength = this.columnSets.length; cs < csLength; cs++) {
						rias.forEach(getColumnSetSubRows(this.subRows.headerRows, cs, 1), function (subRow, sr) {
							this._initSubRowDnd(subRow, dndTypePrefix + cs + '-' + sr);
						}, this);
					}
				}else{
					for (cs = 0, csLength = this.columnSets.length; cs < csLength; cs++) {
						rias.forEach(this.columnSets[cs], function (subRow, sr) {
							this._initSubRowDnd(subRow, dndTypePrefix + cs + '-' + sr);
						}, this);
					}
				}
			}
			else {
				// Iterate subrows->columns.
				rias.forEach(this.subRows, function (subRow, sr) {
					this._initSubRowDnd(subRow, dndTypePrefix + sr);
				}, this);
			}
		}
	});
	ColumnResizer.extend({
		postMixInProperties: function(){
			///增加 this._columnSizes 判断，this._columnSizes 在多个地方使用、创建。
			if(!this._columnSizes){
				this._columnSizes = {};
			}
			this.inherited(arguments);
		},
		postCreate: function () {
			var self = this;

			this.inherited(arguments);

			///增加 onColumnResize
			this.own(rias.on(this.domNode, "dgrid-columnresize", function(evt){
				return self.onColumnResize(evt) != false;
			}));
		},
		onColumnResize: function(evt){
		},
		configStructure: function () {
			var oldSizes = this._oldColumnSizes = rias.mixin({}, this._columnSizes), // shallow clone
				k;

			this._resizedColumns = false;
			///改到 postMixInProperties 中
			//this._columnSizes = {};

			this.inherited(arguments);

			// Remove old column styles that are no longer relevant; this is specifically
			// done *after* calling inherited so that _columnSizes will contain keys
			// for all columns in the new structure that were assigned widths.
			for (k in oldSizes) {
				if (!(k in this._columnSizes)) {
					oldSizes[k].remove();
				}
			}
			delete this._oldColumnSizes;
		},
		_configColumn: function (column) {
			this.inherited(arguments);

			var colId = column.id,
				rule;

			///允许 column.width 为 string
			if ('width' in column) {
				// Update or add a style rule for the specified width
				if (rule = this._columnSizes[colId]) {///改为取 this._columnSizes，因为 this._oldColumnSizes 有可能被 delete
					rule.set('width', (rias.isNumber(column.width) ? column.width + 'px;' : column.width));
				}else {
					///改为用 this.addCssRule
					rule = this.addCssRule('#' + misc.escapeCssIdentifier(this.domNode.id) +
						' .dgrid-column-' + misc.escapeCssIdentifier(colId, '-'),
						'width: ' + (rias.isNumber(column.width) ? column.width + 'px;' : column.width + ';'));
				}
				this._columnSizes[colId] = rule;
			}
		}
	});
	ColumnHider.extend({
		postCreate: function () {
			var self = this;

			this.inherited(arguments);

			///增加 onColumnStateChange
			this.own(rias.on(this.domNode, "dgrid-columnstatechange", function(evt){
				self.onColumnStateChange(evt);
			}));
		},
		onColumnStateChange: function(evt){
		}
	});

	Selection.extend({
		postCreate: function () {
			var self = this;
			this.inherited(arguments);

			///增加 onSelect、onDeselect
			this.own(rias.on(this.domNode, "dgrid-select", function(evt){
				self.onSelect(evt);
			}), rias.on(this.domNode, "dgrid-deselect", function(evt){
				self.onDeselect(evt);
			}));

			this._initSelectionEvents();

			// Force selectionMode setter to run
			var selectionMode = this.selectionMode;
			this.selectionMode = '';
			this._setSelectionMode(selectionMode);
		},
		onSelect: function(evt){
		},
		onDeselect: function(evt){
		},
		getSelectedIds: function(){
			var result = [],
				selection = this.selection, p;
			for(p in selection){
				if(selection[p]){
					result.push(p);
				}
			}
			return result;
		}
	});

	Editor.extend({
		postCreate: function () {
			var self = this;

			this.inherited(arguments);

			///增加 onDataChange、onShowEditor、onHideEditor
			this.own(rias.on(this.domNode, "dgrid-datachange", function(evt){
				return self.onDataChange(evt) != false;
			}), rias.on(this.domNode, "dgrid-editor-show", function(evt){
				self.onShowEditor(evt);
			}), rias.on(this.domNode, "dgrid-editor-hide", function(evt){
				self.onHideEditor(evt);
			}));

			this.on('.dgrid-input:focusin', function () {
				self._focusedEditorCell = self.cell(this);
			});
			this._editorFocusoutHandle = rias.on.pausable(this.domNode, '.dgrid-input:focusout', function () {
				self._focusedEditorCell = null;
			});
			this._listeners.push(this._editorFocusoutHandle);
		},
		onDataChange: function(evt){
		},
		onShowEditor: function(evt){
		},
		onHideEditor: function(evt){
		},

		refresh: function () {
			for (var id in this._editorInstances) {
				var editorInstanceDomNode = this._editorInstances[id].domNode;
				if (editorInstanceDomNode && editorInstanceDomNode.parentNode) {
					// Remove any editor widgets from the DOM before List destroys it, to avoid issues in IE (#1100)
					editorInstanceDomNode.parentNode.removeChild(editorInstanceDomNode);
				}
			}

			/// 增加 return
			return this.inherited(arguments);
		}
	});

	Tree.extend({
		_destroyColumns: function () {
			this.inherited(arguments);
			var listeners = this._treeColumnListeners;

			for (var i = listeners.length; i--;) {
				listeners[i].remove();
			}
			this._treeColumnListeners = [];

			///begin================================///
			///需要重置，以能够重新处理（生成） treeColumn
			///reset somethings
			if(this._treeColumn){
				this._treeColumn._isConfiguredTreeColumn = undefined;
				this._treeColumn.renderCell = this._originalRenderCell;
			}
			this._originalRenderCell = undefined;
			///end=================================///

			this._treeColumn = null;
		},

		_configureTreeColumn: function (column) {
			// summary:
			//		Adds tree navigation capability to a column.
			if (column._isConfiguredTreeColumn) {
				return;
			}

			var originalRenderCell = column.renderCell || this._defaultRenderCell;
			///begin================================///
			///保存，以在 _destroyColumns 中重置
			///save the original renderCell call
			column._originalRenderCell = originalRenderCell;
			///end=================================///

			column._isConfiguredTreeColumn = true;
			column.renderCell = function (object, value, td, options) {
				// summary:
				//		Renders a cell that can be expanded, creating more rows

				var grid = this.grid,
					level = Number(options && options.queryLevel) + 1,
					mayHaveChildren = !grid.collection.mayHaveChildren || grid.collection.mayHaveChildren(object),
					expando, node;

				level = grid._currentLevel = isNaN(level) ? 0 : level;
				expando = this.renderExpando(level, mayHaveChildren,
					grid._expanded[grid.collection.getIdentity(object)], object);
				expando.level = level;
				expando.mayHaveChildren = mayHaveChildren;

				node = originalRenderCell.call(this, object, value, td, options);
				if (node && node.nodeType) {
					td.appendChild(expando);
					td.appendChild(node);
				}
				else {
					td.insertBefore(expando, td.firstChild);
				}
			};

			var clicked; // tracks row that was clicked (for expand dblclick event handling)

			this._treeColumn = column;

			var grid = this,
				colSelector = '.dgrid-content .dgrid-column-' + column.id;

			if (typeof column.renderExpando !== 'function') {
				column.renderExpando = this._defaultRenderExpando;
			}

			// Set up the event listener once and use event delegation for better memory use.
			this._treeColumnListeners.push(this.on(column.expandOn ||
				'.dgrid-expando-icon:click,' + colSelector + ':dblclick,' + colSelector + ':keydown',
				function (event) {
					var row = grid.row(event);
					if ((!grid.collection.mayHaveChildren || grid.collection.mayHaveChildren(row.data))
						&& (event.type !== 'keydown' || event.keyCode === 32)
						&& !(event.type === 'dblclick' && clicked && clicked.count > 1 && row.id === clicked.id
							&& event.target.className.indexOf('dgrid-expando-icon') > -1)) {
						clicked && clicked.count++;///FIX#1255
						grid.expand(row);
					}

					// If the expando icon was clicked, update clicked object to prevent
					// potential over-triggering on dblclick (all tested browsers but IE < 9).
					if (event.target.className.indexOf('dgrid-expando-icon') > -1) {
						if (clicked && clicked.id === grid.row(event).id) {
							clicked.count++;
						}
						else {
							clicked = {
								id: grid.row(event).id,
								count: 1
							};
						}
					}
				})
			);

			if (rias.has('touch')) {
				// Also listen on double-taps of the cell.
				this._treeColumnListeners.push(this.on(touchUtil.selector(colSelector, touchUtil.dbltap),
					function () {
						grid.expand(this);
					}));
			}

		}

	});

	function appendIfNode(parent, subNode) {
		if (subNode && subNode.nodeType) {
			parent.appendChild(subNode);
		}
	}
	Grid.extend({
		postMixInProperties: function(){
			///增加 this._columnStyles 。
			if(!this._columnStyles){
				this._columnStyles = {};
			}
			this.inherited(arguments);
		},
		destroy: function () {
			// Run _destroyColumns first to perform any column plugin tear-down logic.
			this._destroyColumns();
			if (this._sortListener) {
				this._sortListener.remove();
			}
			///增加 this._columnStyles 。
			for (var name in this._columnStyles) {
				this._columnStyles[name].remove();
			}

			this.inherited(arguments);
		},
		postCreate: function () {
			var self = this;

			this.inherited(arguments);

			///增加 onSort，貌似没起作用
			this.own(rias.on(this.domNode, "dgrid-sort", function(evt){
				self.onSort(evt);
			}));
		},
		onSort: function(evt){
		},
		styleColumn: function (colId, css, /*String*/parentCss) {
			///增加 this._columnStyles
			parentCss = parentCss || "";
			var sId = colId + parentCss,
				rule = this._columnStyles[sId];
			if (rule) {
				rule.set(css);
			}else{
				rule = this.addCssRule('#' + misc.escapeCssIdentifier(this.domNode.id) + " " + parentCss + ' .dgrid-column-' + misc.escapeCssIdentifier(colId, '-'), css);
				this._columnStyles[sId] = rule;
			}
			return rule;
		},
		_configColumn: function (column, rowColumns, prefix) {
			var style = {},
				b;
			///增加 cell 的 style
			if(column.style){
				rias.mixinDeep(style, rias.dom.styleToObject(column.style));
				b = 1;
			}
			if(column.align){
				style["text-align"] = column.align;
				b = 1;
			}
			if(b){
				this.styleColumn(column.id, style, " .dgrid-content");
			}
			this.inherited(arguments);
		},
		_defaultRenderCell: function (object, value, td) {
			if (this.formatter) {
				// Support formatter, with or without formatterScope
				var formatter = this.formatter,
					formatterScope = this.grid.formatterScope;
				/// 增加 try..catch
				try{
					td.innerHTML = typeof formatter === 'string' && formatterScope ?
						formatterScope[formatter](value, object) : this.formatter(value, object);
				}catch(e){
					console.error(rias.captureStackTrace(e));
					td.appendChild(rias.dom.doc.createTextNode(value));
				}
			}
			else if (value != null) {
				td.appendChild(rias.dom.doc.createTextNode(value));
			}
		},
		/*_createBodyRowCell: function (cellElement, column, item, options) {
			var cellData = item;

			// Support get function or field property (similar to DataGrid)
			if (column.get) {
				cellData = column.get(item);
			}else if ('field' in column && column.field !== '_item') {
				cellData = item[column.field];
			}

			if (column.renderCell) {
				// A column can provide a renderCell method to do its own DOM manipulation,
				// event handling, etc.
				appendIfNode(cellElement, column.renderCell(item, cellData, cellElement, options));
			}else {
				this._defaultRenderCell.call(column, item, cellData, cellElement, options);
			}
		},*/

		resize: function (changeSize, resultSize) {
			var box = this.inherited(arguments);
			if(box){
				// extension of List.resize to allow accounting for
				// column sizes larger than actual grid area
				var headerTableNode = this.headerNode.firstChild,
					contentNode = this.contentNode,
					width;
				// Force contentNode width to match up with header width.
				contentNode.style.width = ''; // reset first
				if (contentNode && headerTableNode) {
					if ((width = headerTableNode.offsetWidth) > contentNode.offsetWidth) {
						// update size of content node if necessary (to match size of rows)
						// (if headerTableNode can't be found, there isn't much we can do)
						contentNode.style.width = width + 'px';
					}
				}
			}
			return box;
		}
	});

	return Grid;

});