
//RIAStudio client runtime widget - DGrid


/// dgrid._StoreMixin.constructor 中 aspect.before -> this.before		//// constructor 无法 extend

/// ///dgrid.Selection._initSelectionEvents 中 aspect.before -> this.before

/// ///dgrid.Keyboard.postCreate 中 aspect.after -> grid.after
/// ///dgrid.ColumnSet.postCreate 中 aspect.after -> this.after
/// ///dgrid.extensions.Dnd 中 aspect.after -> this.after

/// ///dgrid.ColumnSet._putScroller 中 grid._listeners.push(on), horizMouseWheel 中 grid._listeners.push(on)
/// ///dgrid.Editor._createEditor 中 grid._listeners.push(on)
/// ///dgrid.Keyboard.postCreate 中 grid._listeners.push(on)
/// ///dgrid.OnDemandList.postCreate 中 grid._listeners.push(on)
/// ///dgrid.Selection._initSelectionEvents 中 grid._listeners.push(on)
/// ///dgrid.Tree.expand 中 grid._listeners.push(on)

define([
	"rias",

	"dgrid/List",
	"dgrid/Grid",
	"dgrid/_StoreMixin",
	"dgrid/OnDemandList",
	"dgrid/OnDemandGrid",
	"dgrid/CellSelection",
	"dgrid/ColumnSet",
	"dgrid/Editor",
	"dgrid/Keyboard",
	"dgrid/Selection",
	"dgrid/Selector",
	"dgrid/Tree",
	//"dgrid/GridFromHtml",
	//"dgrid/GridWithColumnSetsFromHtml",
	"dgrid/extensions/ColumnHider",
	"dgrid/extensions/ColumnResizer",
	"dgrid/extensions/ColumnReorder",
	"dgrid/extensions/CompoundColumns",
	//"dgrid/extensions/DijitRegistry",
	"dgrid/extensions/DnD",
	//"dgrid/extensions/Pagination",

	"dgrid/util/misc",
	"dojo/has!touch?dgrid/util/touch"

], function(rias,
			List, Grid, _StoreMixin, OnDemandList, OnDemandGrid, CellSelection, ColumnSet, Editor, Keyboard, Selection, Selector, Tree,
			//GridFromHtml, GridWithColumnSetsFromHtml,
			ColumnHider, ColumnResizer, ColumnReorder, CompoundColumns, //DijitRegistry, Dnd, Pagination,
			DnD,
			miscUtil, touchUtil) {

	var _WidgetBase = rias.getObject("dijit._WidgetBase");
	var autoId = 0;
	function generateId() {
		return "riaswDGrid_" + autoId++;
	}

	rias.theme.loadRiasCss([
		"grid/dgrid/dgrid.css",
		"grid/dgrid/dgridskin.css"
	], false, function(){
		rias.theme.addCssRule('.dgrid-scrollbar-width', 'width: ' + rias.theme.scrollbarWidth + 'px');
		rias.theme.addCssRule('.dgrid-scrollbar-height', 'height: ' + rias.theme.scrollbarHeight + 'px');

		if (rias.theme.scrollbarWidth !== 17) {
			// for modern browsers, we can perform a one-time operation which adds
			// a rule to account for scrollbar width in all grid headers.
			rias.theme.addCssRule('.dgrid-header-row', 'right: ' + rias.theme.scrollbarWidth + 'px');
			rias.theme.addCssRule('.dgrid-footer-summary-row', 'right: ' + rias.theme.scrollbarWidth + 'px');
			// add another for RTL grids
			rias.theme.addCssRule('.dgrid-rtl-swap .dgrid-header-row', 'left: ' + rias.theme.scrollbarWidth + 'px');
			rias.theme.addCssRule('.dgrid-rtl-swap .dgrid-footer-summary-row', 'left: ' + rias.theme.scrollbarWidth + 'px');
		}
	});

	miscUtil.addCssRule = function(selector, css){
		return rias.theme.addCssRule(selector, css);
	};

	List.extend({

		postscript: function(/*Object?*/params, /*DomNode|String*/srcNodeRef){
			var grid = this;

			(this._Row = function (id, object, element) {
				this.id = id;
				this.data = object;
				this.element = element;
			}).prototype.remove = function () {
				grid.removeRow(this.element);
			};

			if (srcNodeRef) {
				// normalize srcNodeRef and store on instance during create process.
				// Doing this in postscript is a bit earlier than dijit would do it,
				// but allows subclasses to access it pre-normalized during create.
				this.srcNodeRef = srcNodeRef = srcNodeRef.nodeType ? srcNodeRef : byId(srcNodeRef);
			}

			/// inherited _WidgetBase
			this.inherited(arguments);
		},
		create: function (params, srcNodeRef) {
			this._introspect();

			this.ownerDocument = this.ownerDocument || (srcNodeRef ? srcNodeRef.ownerDocument : rias.dom.doc);
			this.ownerDocumentBody = rias.dom.body(this.ownerDocument);
			var domNode = this.domNode = srcNodeRef || rias.dom.create('div'),
				cls;

			if (params) {
				this.params = params;
				rias.safeMixin(this, params);
				//rias.mixin(this, params);

				// Check for initial class or className in params or on domNode
				cls = params['class'] || params.className || domNode.className;
			}

			// ensure arrays and hashes are initialized
			this.sort = this.sort || [];
			this._listeners = [];
			this._rowIdToObject = {};

			this.postMixInProperties && this.postMixInProperties();

			// Apply id to widget and domNode,
			// from incoming node, widget params, or autogenerated.
			this.id = domNode.id = domNode.id || this.id || generateId();
			rias.registry.add(this);

			// Perform initial rendering, and apply classes if any were specified.
			this.buildRendering();
			if (cls) {
				//setClass.call(this, cls);
				rias.dom.replaceClass(this.domNode, cls, this._class || '');
				// Store for later retrieval/removal.
				this._class = cls;
			}

			//this._applyAttributes();///需要在 buildRendering 之后。
			this.postCreate(params);

			// remove srcNodeRef instance property post-create
			//delete this.srcNodeRef;

			this._created = true;

			// to preserve "it just works" behavior, call startup if we're visible
			if (this.domNode.offsetHeight) {
				this.startup();
			}
		},
		buildRendering: function () {
			var domNode = this.domNode,
				addUiClasses = this.addUiClasses,
				self = this,
				headerNode,
				bodyNode,
				footerNode,
				isRTL;

			// Detect RTL on html/body nodes; taken from dojo/dom-geometry
			isRTL = this.isRTL = (rias.dom.docBody.dir || rias.dom.doc.documentElement.dir ||
				rias.dom.docBody.style.direction).toLowerCase() === 'rtl';

			// Clear out className (any pre-applied classes will be re-applied via the
			// class / className setter), then apply standard classes/attributes
			domNode.className = '';

			domNode.setAttribute('role', 'grid');
			rias.dom.addClass(domNode, 'dgrid dgrid-' + this.listType + (addUiClasses ? ' ui-widget' : ''));

			///增加 topTools
			if(this.topTools){
				rias.dom.place(this.topTools.domNode, domNode, "first");
				rias.dom.addClass(this.topTools.domNode, 'dgrid-header dgrid-header-tools' + (addUiClasses ? ' ui-widget-header' : ''));
			}
			// Place header node (initially hidden if showHeader is false).
			headerNode = this.headerNode = rias.dom.create('div', {
				className: 'dgrid-header dgrid-header-row' + (addUiClasses ? ' ui-widget-header' : '') +
					(this.showHeader ? '' : ' dgrid-header-hidden')
			}, domNode);

			bodyNode = this.bodyNode = rias.dom.create('div', {
				className: 'dgrid-scroller'
			}, domNode);

			// Firefox 4+ adds overflow: auto elements to the tab index by default;
			// force them to not be tabbable, but restrict this to Firefox,
			// since it breaks accessibility support in other browsers
			if (rias.has('ff')) {
				bodyNode.tabIndex = -1;
			}

			this.headerScrollNode = rias.dom.create('div', {
				className: 'dgrid-header dgrid-header-scroll dgrid-scrollbar-width' + (addUiClasses ? ' ui-widget-header' : '')
				//className: 'dgrid-header dgrid-header-scroll ' + (addUiClasses ? ' ui-widget-header' : '')
			}, domNode);

			// Place footer node (initially hidden if showFooter is false).
			footerNode = this.footerNode = rias.dom.create('div', {
				className: 'dgrid-footer' + (this.showFooter ? '' : ' dgrid-footer-hidden')
			}, domNode);

			if (isRTL) {
				domNode.className += ' dgrid-rtl' +
					(rias.has('dom-rtl-scrollbar-left') ? ' dgrid-rtl-swap' : '');
			}

			this._listeners.push(rias.on(bodyNode, 'scroll', function (event) {
				if (self.showHeader) {
					// keep the header aligned with the body
					headerNode.scrollLeft = event.scrollLeft || bodyNode.scrollLeft;
				}
				// re-fire, since browsers are not consistent about propagation here
				event.stopPropagation();
				rias.on.emit(domNode, 'scroll', {scrollTarget: bodyNode});
			}));
			this.configStructure();
			this.renderHeader();

			this.contentNode = this.touchNode = rias.dom.create('div', {
				className: 'dgrid-content' + (addUiClasses ? ' ui-widget-content' : '')
			}, this.bodyNode);

			// add window resize handler, with reference for later removal if needed
			this._listeners.push(this._resizeHandle = rias.dom.Viewport.on("resize", miscUtil.throttleDelayed(function(){
				if (this._started) {
					this.resize();
				}
			}, this)));

			if (this.baseClass) {
				var classes = this.baseClass.split(" ");
				if (!this.isLeftToRight()) {
					classes = classes.concat(rias.map(classes, function (name) {
						return name + "Rtl";
					}));
				}
				rias.dom.addClass(this.domNode, classes);
			}

			// Note: for dojo 2.0 may rename widgetId to dojo._scopeName + "_widgetId"
			this.domNode.setAttribute('widgetId', this.id);
		},
		postCreate: function () {
			this.inherited(arguments);
		},
		startup: function () {
			if (this._started) {
				return;
			}
			/// inherited _WidgetBase
			this.inherited(arguments);
			this._started = true;
			// apply sort (and refresh) now that we're ready to render
			this.set('sort', this.sort);
			var widget = this.getParent();
			// If we have a parent layout container widget, it will handle resize,
			// so remove the window resize listener added by List.
			if (widget && widget.isLayoutContainer) {
				this._resizeHandle.remove();
			}
			this.resize();
		},
		destroy: function (preserveDom) {
			if(this.topTools){
				rias.destroy(this.topTools);
			}
			// Remove any event listeners and other such removables
			if (this._listeners) { // Guard against accidental subsequent calls to destroy
				for (var i = this._listeners.length; i--;) {
					this._listeners[i].remove();
				}
				this._listeners = null;
			}

			/// inherited _WidgetBase
			this.inherited(arguments);

			this._started = false;
			this.cleanup();

			// destroy DOM
			//rias.dom.destroy(this.domNode);
		},

		get: function (/*String*/ name /*, ... */) {
			var fn = '_get' + name.charAt(0).toUpperCase() + name.slice(1);

			if (typeof this[fn] === 'function') {
				return this[fn].apply(this, [].slice.call(arguments, 1));
			}

			///允许使用 _getXXXAttr
			//if (!rias.has('dojo-built') && typeof this[fn + 'Attr'] === 'function') {
			//	console.warn('dgrid: Use ' + fn + ' instead of ' + fn + 'Attr for getting ' + name);
			//}
			return this.inherited(arguments);
		},
		set: function (/*String*/ name, /*Object*/ value /*, ... */) {
			if (typeof name === 'object') {
				for (var k in name) {
					this.set(k, name[k]);
				}
			}else {
				var fn = '_set' + name.charAt(0).toUpperCase() + name.slice(1);

				if (typeof this[fn] === 'function') {
					this[fn].apply(this, [].slice.call(arguments, 1));
				}else {
					///允许使用 _setXXXAttr
					//if (!rias.has('dojo-built') && typeof this[fn + 'Attr'] === 'function') {
					//	console.warn('dgrid: Use ' + fn + ' instead of ' + fn + 'Attr for setting ' + name);
					//}
					this.inherited(arguments);
				}
			}

			return this;
		},

		_internalResize: function(box){
			//console.debug(this.id, box);
			rias.dom.setMarginBox(this.domNode, box);
			//box = rias.dom.getMarginBox(node);
			return box;
		},
		resize: function (changeSize, resultSize) {
			if(this.isDestroyed(true)){
				return;
			}
			var v,
				box;
			v = this._started && this.get("visible");
			if(!v){
				//this._needResize = true;
				this._changeSize = rias.mixin(this._changeSize, changeSize);
				this._resultSize = rias.mixin(this._resultSize, resultSize);
				return;
			}
			this._wasResized = true;
			box = resultSize || {};

			box = rias.mixin(this._changeSize, changeSize, box);
			this._changeSize = undefined;
			this._resultSize = undefined;

			box = this._internalResize(box);
			//this._needResize = undefined;

			var bodyNode = this.bodyNode,
				headerNode = this.headerNode,
				footerSummaryNode = this.footerSummaryNode,
				footerNode = this.footerNode,
				headerHeight = headerNode.offsetHeight,
				footerHeight = this.showFooter ? footerNode.offsetHeight : 0;

			this.headerScrollNode.style.top = (this.topTools ? this.topTools.domNode.offsetHeight : 0) + "px";
			this.headerScrollNode.style.height = headerHeight + "px";
			if(footerSummaryNode){
				footerSummaryNode.style.bottom = footerHeight + "px";
				this.footerSummaryScrollNode.style.bottom = footerHeight + "px";
				this.footerSummaryScrollNode.style.height = footerSummaryNode.offsetHeight + "px";
			}

			//bodyNode.style.height = (this.domNode.clientHeight - rias.theme.scrollbarHeight
			//	- (this.topTools ? this.topTools.domNode.offsetHeight : 0)
			//	- headerHeight
			//	- (footerSummaryNode ? footerSummaryNode.offsetHeight : 0)
			//	- footerHeight) + 'px';
			bodyNode.style.marginTop = (this.topTools ? headerHeight + this.topTools.domNode.offsetHeight : headerHeight) + 'px';
			bodyNode.style.marginBottom = ((footerSummaryNode ? footerSummaryNode.offsetHeight : 0) + footerHeight) + 'px';

			this.adjustVScroll();

			return box;
		},

		adjustVScroll: function(){
			///增加
			//rias.dom.toggleClass(this.headerScrollNode, "dgrid-scrollbar-width", !!this.bodyNode.style.overflow);
			if(this.contentNode.scrollHeight > this.contentNode.offsetHeight){
				rias.dom.visible(this.headerScrollNode, true);
				this.headerNode.style.right = "";
			}else{
				rias.dom.visible(this.headerScrollNode, false);
				this.headerNode.style.right = "0";
			}
		},
		renderArray: function (results, beforeNode, options) {
			// summary:
			//		Renders an array of objects as rows, before the given node.

			options = options || {};
			var self = this,
				start = options.start || 0,
				rowsFragment = rias.dom.doc.createDocumentFragment(),
				rows = [],
				container,
				i = 0,
				len = results.length;

			if (!beforeNode) {
				this._lastCollection = results;
			}

			// Insert a row for each item into the document fragment
			while (i < len) {
				///增加 options.rowNum
				options.rowNum = start + 1;
				rows[i] = this.insertRow(results[i], rowsFragment, null, start++, options);
				i++;
			}

			// Insert the document fragment into the appropriate position
			container = beforeNode ? beforeNode.parentNode : self.contentNode;
			if (container && container.parentNode &&
				(container !== self.contentNode || len)) {
				container.insertBefore(rowsFragment, beforeNode || null);
				if (len) {
					self.adjustRowIndices(rows[len - 1]);
				}
			}

			return rows;
		}

	});

	/*_StoreMixin.extend({
		//// constructor 无法 extend
		constructor: function () {
			// Create empty objects on each instance, not the prototype
			this.dirty = {};
			this._updating = {}; // Tracks rows that are mid-update
			this._columnsWithSet = {};

			// Reset _columnsWithSet whenever column configuration is reset
			this.before(this, 'configStructure', rias.hitch(this, function () {
				this._columnsWithSet = {};
			}));
		},
	});*/

	OnDemandList.extend({
		postCreate: function () {
			this.inherited(arguments);
			var self = this;
			// check visibility on scroll events
			this._listeners.push(rias.on(this.bodyNode, 'scroll',
				miscUtil[this.pagingMethod](function (event) {
					self._processScroll(event);
				}, null, this.pagingDelay)
			));
		}
	});

	var colsetidAttr = 'data-dgrid-column-set-id';

	function adjustScrollLeft(grid, root) {
		// Adjusts the scroll position of each column set in each row under the given root.
		// (root can be a row, or e.g. a tree parent row element's connected property to adjust children)
		var scrollLefts = grid._columnSetScrollLefts;
		rias.dom.query('.dgrid-column-set', root).forEach(function (element) {
			element.scrollLeft = scrollLefts[element.getAttribute(colsetidAttr)];
		});
	}
	function getColumnSetSubRows(subRows, columnSetId, startRow) {
		// Builds a subRow collection that only contains columns that correspond to
		// a given column set id.
		if (!subRows || !subRows.length) {
			return;
		}
		var subset = [],
			idPrefix = columnSetId + '-',
			i = startRow || 0,
			numRows = subRows.length;
		for (; i < numRows; i++) {
			var row = subRows[i];
			var subsetRow = [];
			subsetRow.className = row.className;
			for (var k = 0, numCols = row.length; k < numCols; k++) {
				var column = row[k];
				// The column id begins with the column set id.
				//if (column.id != null && column.id.indexOf(idPrefix) === 0) {
				if (column.id != null && column._columnSetPrefix === idPrefix) {
					column.columnSetId = columnSetId;
					subsetRow.push(column);
				}
			}
			subset.push(subsetRow);
		}
		return subset;
	}
	function isRootNode(node, rootNode) {
		// If we've reached the top-level node for the grid then there is no parent column set.
		// This guard prevents an error when scroll is initated over some node in the grid that is not a descendant of
		// a column set. This can happen in a grid that has empty space below its rows (grid is taller than the rows).
		return (rootNode && node === rootNode) || rias.dom.hasClass(node, 'dgrid');
	}
	function findParentColumnSet(node, root) {
		// WebKit will invoke mousewheel handlers with an event target of a text
		// node; check target and if it's not an element node, start one node higher
		// in the tree
		if (node.nodeType !== 1) {
			node = node.parentNode;
		}

		while (node && !rias.dom.query.matches(node, '.dgrid-column-set[' + colsetidAttr + ']', root)) {
			if (isRootNode(node, root)) {
				return null;
			}
			node = node.parentNode;
		}

		return node;
	}
	var pointerMap = {
		start: 'down',
		end: 'up'
	};
	function getTouchEventName(type) {
		// Given 'start', 'move', or 'end', returns appropriate touch or pointer event name
		// based on browser support.  (Assumes browser supports touch or pointer.)
		var hasPointer = rias.has('pointer');
		if (hasPointer) {
			type = pointerMap[type] || type;
			if (hasPointer.slice(0, 2) === 'MS') {
				return 'MSPointer' + type.slice(0, 1).toUpperCase() + type.slice(1);
			}
			else {
				return 'pointer' + type;
			}
		}
		return 'touch' + type;
	}
	var horizTouchMove = rias.has('touch') && function (grid) {
		return function (target, listener) {
			var listeners = [
				rias.on(target, getTouchEventName('start'), function (event) {
					if (!grid._currentlyTouchedColumnSet) {
						var node = findParentColumnSet(event.target, target);
						// If handling pointer events, only react to touch;
						// MSPointerDown (IE10) reports 2, 3, 4 for touch, pen, mouse
						if (node && (!event.pointerType || event.pointerType === 'touch' || event.pointerType === 2)) {
							grid._currentlyTouchedColumnSet = node;
							grid._lastColumnSetTouchX = event.clientX;
							grid._lastColumnSetTouchY = event.clientY;
						}
					}
				}),
				rias.on(target, getTouchEventName('move'), function (event) {
					if (grid._currentlyTouchedColumnSet === null) {
						return;
					}
					var node = findParentColumnSet(event.target);
					if (!node) {
						return;
					}
					listener.call(null, grid, node, grid._lastColumnSetTouchX - event.clientX);
					grid._lastColumnSetTouchX = event.clientX;
					grid._lastColumnSetTouchY = event.clientY;
				}),
				rias.on(target, getTouchEventName('end'), function () {
					grid._currentlyTouchedColumnSet = null;
				})
			];

			return {
				remove: function () {
					for (var i = listeners.length; i--;) {
						listeners[i].remove();
					}
				}
			};
		};
	};
	var horizMouseWheel = rias.has('event-mousewheel') || rias.has('event-wheel') ? function (grid) {
		return function (target, listener) {
			return grid._listeners.push(rias.on(target, rias.has('event-wheel') ? 'wheel' : 'mousewheel', function (event) {
				var node = findParentColumnSet(event.target, target),
					deltaX;

				if (!node) {
					return;
				}

				// Normalize reported delta value:
				// wheelDeltaX (webkit, mousewheel) needs to be negated and divided by 3
				// deltaX (FF17+, wheel) can be used exactly as-is
				deltaX = event.deltaX || -event.wheelDeltaX / 3;
				if (deltaX) {
					// only respond to horizontal movement
					listener.call(null, grid, node, deltaX);
				}
			}))[0];
		};
	} : function (grid) {
		return function (target, listener) {
			return grid._listeners.push(rias.on(target, '.dgrid-column-set[' + colsetidAttr + ']:MozMousePixelScroll', function (event) {
				if (event.axis === 1) {
					// only respond to horizontal movement
					listener.call(null, grid, this, event.detail);
				}
			}))[0];
		};
	};
	function horizMoveHandler(grid, colsetNode, amount) {
		var id = colsetNode.getAttribute(colsetidAttr),
			scroller = grid._columnSetScrollers[id],
			scrollLeft = scroller.scrollLeft + amount;

		scroller.scrollLeft = scrollLeft < 0 ? 0 : scrollLeft;
	}
	ColumnSet.extend({
		postMixInProperties: function(){
			///增加 this._columnSetRules 判断
			this._columnSetRules = {};
			///增加 this._columnSizes 判断，this._columnSizes 在多个地方使用、创建。
			if(!this._columnSizes){
				this._columnSizes = {};
			}
			this.inherited(arguments);
		},
		/// 需要使用 this.own(aspect.after)
		postCreate: function () {
			var self = this;
			this.inherited(arguments);

			this.on(horizMouseWheel(this), horizMoveHandler);
			if (rias.has('touch')) {
				this.on(horizTouchMove(this), horizMoveHandler);
			}

			this.on('.dgrid-column-set:dgrid-cellfocusin', function (event) {
				self._onColumnSetCellFocus(event, this);
			});

			if (typeof this.expand === 'function') {
				this.after(this, 'expand', function (promise, args) {
					promise.then(function () {
						var row = self.row(args[0]);
						if (self._expanded[row.id]) {
							// scrollLeft changes can't take effect on collapsed child rows;
							// ensure they are properly updated once re-expanded.
							adjustScrollLeft(self, row.element.connected);
						}
					});
					return promise;
				});
			}
		},
		startup: function(){
			///增加 onColumnResize
			var self = this;
			if (this._started) {
				return;
			}
			/// inherited _WidgetBase
			this.inherited(arguments);
			this._started = true;

			this._listeners.push(rias.on(this.domNode, "dgrid-columnresize", function(evt){
				self._calColumnSet();
			}));
		},
		destroy: function () {
			this.inherited(arguments);

			///增加 this._columnSizes
			var name;
			for (name in this._columnSizes) {
				this._columnSizes[name].remove();
			}
			///增加 this._columnSetRules
			for (name in this._columnSetRules) {
				this._columnSetRules[name].remove();
			}
			this._columnSetScrollerNode = undefined;
		},

		styleColumnSet: function (colsetId, css, /*String*/parentCss) {
			// summary:
			//		Dynamically creates a stylesheet rule to alter a columnset's style.

			///增加 this._columnSetRules
			parentCss = parentCss || "";
			var sId = colsetId + parentCss,
				rule = this._columnSetRules[sId];
			if (rule) {
				rule.set(css);
			}else{
				rule = this.addCssRule('#' + miscUtil.escapeCssIdentifier(this.domNode.id) + " " + parentCss + ' .dgrid-column-set-' + miscUtil.escapeCssIdentifier(colsetId, '-'), css);
				this._columnSetRules[sId] = rule;
			}
			if(this._columnSetScrollers){
				this._positionScrollers();
			}
			return rule;
		},
		_configColumns: function (prefix, rowColumns) {
			for (var i = 0, l = this.columnSets.length; i < l; i++) {
				var columnSet = this.columnSets[i];
				for (var j = 0; j < columnSet.length; j++) {
					for (var k = 0; k < columnSet[j].length; k++) {
						columnSet[j][k]._columnSetPrefix = i + "-";
					}
				}
			}
			return this.inherited(arguments);
		},
		createRowCells: function (tag, each, subRows, object, options) {
			var row = rias.dom.create('table', { className: 'dgrid-row-table' });
			var tbody = rias.dom.create('tbody', null, row);
			var tr = rias.dom.create('tr', null, tbody);
			var i, l, cell,
				columnSetId;///增加 columnSetId
			for (i = 0, l = this.columnSets.length; i < l; i++) {
				// iterate through the columnSets
				columnSetId = i;
				cell = rias.dom.create(tag, {
					className: 'dgrid-column-set-cell dgrid-column-set-' + i
				}, tr);
				cell = rias.dom.create('div', {
					className: 'dgrid-column-set'
				}, cell);
				cell.setAttribute(colsetidAttr, columnSetId);
				var subset = getColumnSetSubRows(subRows || this.subRows, columnSetId) || this.columnSets[i];
				cell.appendChild(this.inherited(arguments, [tag, each, subset, object, options]));
			}
			return row;
		},
		renderHeader: function () {
			// summary:
			//		Setup the headers for the grid
			this.inherited(arguments);

			var columnSets = this.columnSets,
				scrollers = this._columnSetScrollers,
				grid = this;

			function reposition() {
				grid._positionScrollers();
			}

			this._columnSetScrollerContents = {};
			this._columnSetScrollLefts = {};

			if (scrollers) {
				// this isn't the first time; destroy existing scroller nodes first
				for (i in scrollers) {
					rias.dom.destroy(scrollers[i]);
				}
			} else {
				// first-time-only operations: hook up event/aspected handlers
				///增加 this.own
				this.own(
					rias.after(this, 'resize', reposition, true),
					rias.after(this, 'styleColumn', reposition, true)
				);
				this._columnSetScrollerNode = rias.dom.create('div', {
					className: 'dgrid-column-set-scroller-container'
				}, this.footerNode, 'after');
			}

			// reset to new object to be populated in loop below
			scrollers = this._columnSetScrollers = {};

			for (i = 0, l = columnSets.length; i < l; i++) {
				this._putScroller(columnSets[i], i);
			}

			this._positionScrollers();
		},

		adjustVScroll: function(){
			///增加
			this.inherited(arguments);
			if(this._columnSetScrollers){
				this._positionScrollers();
			}
		},

		_positionScrollers: function () {
			var domNode = this.domNode,
				scrollers = this._columnSetScrollers,
				scrollerContents = this._columnSetScrollerContents,
				columnSets = this.columnSets,
				footerSummaryNode = this.footerSummaryNode,
				footerHeight = this.showFooter ? this.footerNode.offsetHeight : 0,
				scrollerWidth = 0,
				numScrollers = 0, // tracks number of visible scrollers (sets w/ overflow)
				i, l, columnSetElement, contentWidth;

			for (i = 0, l = columnSets.length; i < l; i++) {
				// iterate through the columnSets
				columnSetElement = rias.dom.query('.dgrid-column-set[' + colsetidAttr + '="' + i + '"]', domNode)[0];
				scrollerWidth = columnSetElement.offsetWidth;
				contentWidth = columnSetElement.firstChild.offsetWidth;
				scrollerContents[i].style.width = contentWidth + 'px';
				scrollers[i].style.width = scrollerWidth + 'px';

				if (rias.has('ie') < 9) {
					// IE seems to need scroll to be set explicitly
					scrollers[i].style.overflowX = contentWidth > scrollerWidth ? 'scroll' : 'auto';
				}

				// Keep track of how many scrollbars we're showing
				if (contentWidth > scrollerWidth) {
					numScrollers++;
				}
			}

			numScrollers = (numScrollers ? rias.theme.scrollbarHeight : 0);
			if(footerSummaryNode){
				footerSummaryNode.style.bottom = (footerHeight + numScrollers) + "px";
				this.footerSummaryScrollNode.style.bottom = (footerHeight + numScrollers) + "px";
				this.footerSummaryScrollNode.style.height = footerSummaryNode.offsetHeight + "px";
			}
			this._columnSetScrollerNode.style.bottom = footerHeight + 'px';

			// Align bottom of body node depending on whether there are scrollbars
			/// 已经设置了 marginBottom
			this.bodyNode.style.bottom = numScrollers + 'px';
		},
		_putScroller: function (columnSet, i) {
			// function called for each columnSet
			var scroller = this._columnSetScrollers[i] = rias.dom.create('span', {
				// IE8 needs dgrid-scrollbar-height class for scrollbar to be visible,
				// but for some reason IE11's scrollbar arrows become unresponsive, so avoid applying it there
				className: 'dgrid-column-set-scroller dgrid-column-set-scroller-' + i +
					(rias.has('ie') < 9 ? ' dgrid-scrollbar-height' : '')
			}, this._columnSetScrollerNode);
			scroller.setAttribute(colsetidAttr, i);

			this._columnSetScrollerContents[i] = rias.dom.create('div', {
				className: 'dgrid-column-set-scroller-content'
			}, scroller);
			this._listeners.push(rias.on(scroller, 'scroll', rias.hitch(this, '_onColumnSetScroll')));
		},

		_calColumnSet: function(){
			function _getsw(node, sw){
				var w = 0;
				if(sw.indexOf("em") >= 0){
					rias.theme.testElement(node, function(el){
						w += (parseFloat(sw) * rias.dom.getPadExtents(el).t);
					});
				}else{
					w += parseFloat(sw);
				}
				return rias.dom.box2marginBox(node, {w: w}).w;
			}
			var self = this,
				cols, col, colw, w, s,// ws,
				i, l, rule;
			for (i = 0, l = this.columnSets.length - 1; i < l; i++) {
				///最后一个 columnSets 不能设置
				if(this.columnSetWidths && this.columnSetWidths[i]){
					this.styleColumnSet(i, {
						width: rias.isNumber(this.columnSetWidths[i]) ? this.columnSetWidths[i] + "px" : this.columnSetWidths[i]
					});
				}else{
					cols = getColumnSetSubRows(this.subRows && this.subRows.headerRows, i) || this.columnSets[i];
					w = 20;
					rias.forEach(cols[0], function(column, idx){
						if (rule = self._columnSizes[column.id]) {
							colw = rule.get("width");
							colw = _getsw(column.headerNode, colw);
						}else {
							colw = 0;
							s = (rias.dom.styleToObject(column.headerNode.style).width) || column.width;
							if(s){
								colw = _getsw(column.headerNode, s);
							}else if(column._riasrOpColumn){
								rias.forEach(column._riasrOpColumn, function(item){
									colw += _getsw(column.headerNode, (item.text + " ").length + "em");
								});
								colw += 10;
							}else{
								colw = rias.dom.getMarginBox(column.headerNode).w;
							}
							rule = self.addCssRule('#' + miscUtil.escapeCssIdentifier(self.domNode.id) +
								' .dgrid-column-' + miscUtil.escapeCssIdentifier(column.id, '-'),
								'width: ' + rias.dom.marginBox2box(column.headerNode, {w: colw}).w + 'px;');
							self._columnSizes[column.id] = rule;
						}
						w += colw;
					});
					this.styleColumnSet(i, {
						width: w + "px"
					});
				}
			}
		},
		_internalResize: function(box){
			box = this.inherited(arguments);
			this._calColumnSet();
			return box;
		},

		_setColumnSets: function (columnSets) {
			this._destroyColumns();
			this.columnSets = columnSets;
			var scrolls = this._columnSetScrollLefts;
			this._updateColumns();
			if(this.keepScrollPosition){
				for(var id in scrolls){
					if(scrolls[id]){
						this._scrollColumnSet(id, scrolls[id]);
					}
				}
			}
		},
		_onColumnSetCellFocus: function (event, columnSetNode) {
			var focusedNode = event.target;
			/// 排除 resize-handle
			if(focusedNode.className.indexOf("dgrid-resize-handle") >= 0){
				return;
			}
			var columnSetId = columnSetNode.getAttribute(colsetidAttr),
			// columnSetNode's offsetLeft is not always correct,
			// so get the columnScroller to check offsetLeft against
				columnScroller = this._columnSetScrollers[columnSetId],
				elementEdge = focusedNode.offsetLeft - columnScroller.scrollLeft + focusedNode.offsetWidth;

			if (elementEdge > columnSetNode.offsetWidth || columnScroller.scrollLeft > focusedNode.offsetLeft) {
				this._scrollColumnSet(columnSetNode, focusedNode.offsetLeft);
			}
		}

	});

	ColumnReorder.extend({
		postCreate: function () {
			var self = this;

			this.inherited(arguments);

			///增加 onColumnReorder
			this._listeners.push(rias.on(this.domNode, "dgrid-columnreorder", function(evt){
				return self.onColumnReorder(evt) != false;
			}));
		},
		onColumnReorder: function(evt){
		},
		renderHeader: function () {
			function makeDndTypePrefix(gridId) {
				return 'dgrid-' + gridId + '-';
			}
			var dndTypePrefix = makeDndTypePrefix(this.id),
				csLength, cs;

			this.inherited(arguments);

			// After header is rendered, set up a dnd source on each of its subrows.

			this._columnDndSources = [];

			/// 保持与 Grid.renderHeader 和 _createHeaderRowCell 一致，
			/// 增加使用 this.subRows.headerRows
			if (this.columnSets) {
				// Iterate columnsets->subrows->columns.
				if(this.subRows && this.subRows.headerRows){
					for (cs = 0, csLength = this.columnSets.length; cs < csLength; cs++) {
						rias.forEach(getColumnSetSubRows(this.subRows.headerRows, cs, 1), function (subRow, sr) {
							this._initSubRowDnd(subRow, dndTypePrefix + cs + '-' + sr);
						}, this);
					}
				}else{
					for (cs = 0, csLength = this.columnSets.length; cs < csLength; cs++) {
						rias.forEach(this.columnSets[cs], function (subRow, sr) {
							this._initSubRowDnd(subRow, dndTypePrefix + cs + '-' + sr);
						}, this);
					}
				}
			}
			else {
				// Iterate subrows->columns.
				rias.forEach(this.subRows, function (subRow, sr) {
					this._initSubRowDnd(subRow, dndTypePrefix + sr);
				}, this);
			}
		}
	});
	ColumnResizer.extend({
		postMixInProperties: function(){
			///增加 this._columnSizes 判断，this._columnSizes 在多个地方使用、创建。
			if(!this._columnSizes){
				this._columnSizes = {};
			}
			this.inherited(arguments);
		},
		postCreate: function () {
			var self = this;

			this.inherited(arguments);

			///增加 onColumnResize
			this._listeners.push(rias.on(this.domNode, "dgrid-columnresize", function(evt){
				return self.onColumnResize(evt) != false;
			}));
		},
		onColumnResize: function(evt){
		},
		configStructure: function () {
			var oldSizes = this._oldColumnSizes = rias.mixin({}, this._columnSizes), // shallow clone
				k;

			this._resizedColumns = false;
			///改到 postMixInProperties 中
			//this._columnSizes = {};

			this.inherited(arguments);

			// Remove old column styles that are no longer relevant; this is specifically
			// done *after* calling inherited so that _columnSizes will contain keys
			// for all columns in the new structure that were assigned widths.
			for (k in oldSizes) {
				if (!(k in this._columnSizes)) {
					oldSizes[k].remove();
				}
			}
			delete this._oldColumnSizes;
		},
		_configColumn: function (column) {
			this.inherited(arguments);

			var colId = column.id,
				rule;

			///允许 column.width 为 string
			if ('width' in column) {
				// Update or add a style rule for the specified width
				if (rule = this._columnSizes[colId]) {///改为取 this._columnSizes，因为 this._oldColumnSizes 有可能被 delete
					rule.set('width', (rias.isNumber(column.width) ? column.width + 'px;' : column.width));
				}else {
					///改为用 this.addCssRule
					rule = this.addCssRule('#' + miscUtil.escapeCssIdentifier(this.domNode.id) +
						' .dgrid-column-' + miscUtil.escapeCssIdentifier(colId, '-'),
						'width: ' + (rias.isNumber(column.width) ? column.width + 'px;' : column.width + ';'));
				}
				this._columnSizes[colId] = rule;
			}
		}
	});
	ColumnHider.extend({
		postCreate: function () {
			var self = this;

			this.inherited(arguments);

			///增加 onColumnStateChange
			this._listeners.push(rias.on(this.domNode, "dgrid-columnstatechange", function(evt){
				self.onColumnStateChange(evt);
			}));
		},
		onColumnStateChange: function(evt){
		}
	});

	var delegatingInputTypes = {
			checkbox: 1,
			radio: 1,
			button: 1
		},
		hasGridCellClass = /\bdgrid-cell\b/,
		hasGridRowClass = /\bdgrid-row\b/;
	Keyboard.extend({
		postCreate: function () {
			this.inherited(arguments);
			var grid = this;

			function handledEvent(event) {
				// Text boxes and other inputs that can use direction keys should be ignored
				// and not affect cell/row navigation
				var target = event.target;
				return target.type && (!delegatingInputTypes[target.type] || event.keyCode === 32);
			}

			function enableNavigation(areaNode) {
				var cellNavigation = grid.cellNavigation,
					isFocusableClass = cellNavigation ? hasGridCellClass : hasGridRowClass,
					isHeader = areaNode === grid.headerNode,
					initialNode = areaNode;

				function initHeader() {
					if (grid._focusedHeaderNode) {
						// Remove the tab index for the node that previously had it.
						grid._focusedHeaderNode.tabIndex = -1;
					}
					if (grid.showHeader) {
						if (cellNavigation) {
							// Get the focused element. Ensure that the focused element
							// is actually a grid cell, not a column-set-cell or some
							// other cell that should not be focused
							var elements = grid.headerNode.getElementsByTagName('th');
							for (var i = 0, element; (element = elements[i]); ++i) {
								if (isFocusableClass.test(element.className)) {
									grid._focusedHeaderNode = initialNode = element;
									break;
								}
							}
						}
						else {
							grid._focusedHeaderNode = initialNode = grid.headerNode;
						}

						// Set the tab index only if the header is visible.
						if (initialNode) {
							initialNode.tabIndex = grid.tabIndex;
						}
					}
				}

				if (isHeader) {
					// Initialize header now (since it's already been rendered),
					// and aspect after future renderHeader calls to reset focus.
					initHeader();
					grid.after(grid, 'renderHeader', initHeader, true);
				}
				else {
					grid.after(grid, 'renderArray', function (rows) {
						// summary:
						//		Ensures the first element of a grid is always keyboard selectable after data has been
						//		retrieved if there is not already a valid focused element.

						var focusedNode = grid._focusedNode || initialNode;

						// do not update the focused element if we already have a valid one
						if (isFocusableClass.test(focusedNode.className) && areaNode.contains(focusedNode)) {
							return rows;
						}

						// ensure that the focused element is actually a grid cell, not a
						// dgrid-preload or dgrid-content element, which should not be focusable,
						// even when data is loaded asynchronously
						var elements = areaNode.getElementsByTagName('*');
						for (var i = 0, element; (element = elements[i]); ++i) {
							if (isFocusableClass.test(element.className)) {
								focusedNode = grid._focusedNode = element;
								break;
							}
						}

						focusedNode.tabIndex = grid.tabIndex;
						return rows;
					});
				}

				grid._listeners.push(rias.on(areaNode, 'mousedown', function (event) {
					if (!handledEvent(event)) {
						grid._focusOnNode(event.target, isHeader, event);
					}
				}));

				grid._listeners.push(rias.on(areaNode, 'keydown', function (event) {
					// For now, don't squash browser-specific functionalities by letting
					// ALT and META function as they would natively
					if (event.metaKey || event.altKey) {
						return;
					}

					var handler = grid[isHeader ? 'headerKeyMap' : 'keyMap'][event.keyCode];

					// Text boxes and other inputs that can use direction keys should be ignored
					// and not affect cell/row navigation
					if (handler && !handledEvent(event)) {
						handler.call(grid, event);
					}
				}));
			}

			if (this.tabableHeader) {
				enableNavigation(this.headerNode);
				grid._listeners.push(rias.on(this.headerNode, 'dgrid-cellfocusin', function () {
					grid.scrollTo({ x: this.scrollLeft });
				}));
			}
			enableNavigation(this.contentNode);

			this._debouncedEnsureScroll = miscUtil.debounce(this._ensureScroll, this);
		}
	});

	Selection.extend({
		postCreate: function () {
			var self = this;
			this.inherited(arguments);

			///增加 onSelect、onDeselect
			this._listeners.push(rias.on(this.domNode, "dgrid-select", function(evt){
				self.onSelect(evt);
			}));
			this._listeners.push(rias.on(this.domNode, "dgrid-deselect", function(evt){
				self.onDeselect(evt);
			}));

			this._initSelectionEvents();

			// Force selectionMode setter to run
			var selectionMode = this.selectionMode;
			this.selectionMode = '';
			this._setSelectionMode(selectionMode);
		},
		_initSelectionEvents: function () {
			// summary:
			//		Performs first-time hookup of event handlers containing logic
			//		required for selection to operate.

			var grid = this,
				contentNode = this.contentNode,
				selector = this.selectionDelegate;

			this._selectionEventQueues = {
				deselect: [],
				select: []
			};

			if (rias.has('touch') && !rias.has('pointer') && this.selectionTouchEvents) {
				// Listen for taps, and also for mouse/keyboard, making sure not
				// to trigger both for the same interaction
				grid._listeners.push(rias.on(contentNode, touchUtil.selector(selector, this.selectionTouchEvents), function (evt) {
					grid._handleSelect(evt, this);
					grid._ignoreMouseSelect = this;
				}));
				grid._listeners.push(rias.on(contentNode, rias.on.selector(selector, this.selectionEvents), function (event) {
					if (grid._ignoreMouseSelect !== this) {
						grid._handleSelect(event, this);
					}
					else if (event.type === upType) {
						grid._ignoreMouseSelect = null;
					}
				}));
			}
			else {
				// Listen for mouse/keyboard actions that should cause selections
				grid._listeners.push(rias.on(contentNode, rias.on.selector(selector, this.selectionEvents), function (event) {
					grid._handleSelect(event, this);
				}));
			}

			// Also hook up spacebar (for ctrl+space)
			if (this.addKeyHandler) {
				this.addKeyHandler(32, function (event) {
					grid._handleSelect(event, event.target);
				});
			}

			// If allowSelectAll is true, bind ctrl/cmd+A to (de)select all rows,
			// unless the event was received from an editor component.
			// (Handler further checks against _allowSelectAll, which may be updated
			// if selectionMode is changed post-init.)
			if (this.allowSelectAll) {
				this.on('keydown', function (event) {
					if (event[ctrlEquiv] && event.keyCode === 65 &&
						!/\bdgrid-input\b/.test(event.target.className)) {
						event.preventDefault();
						grid[grid.allSelected ? 'clearSelection' : 'selectAll']();
					}
				});
			}

			// Update aspects if there is a collection change
			if (this._setCollection) {
				this.before(this, '_setCollection', function (collection) {
					grid._updateDeselectionAspect(collection);
				});
			}
			this._updateDeselectionAspect();
		},
		onSelect: function(evt){
		},
		onDeselect: function(evt){
		},
		getSelectedIds: function(){
			var result = [],
				selection = this.selection, p;
			for(p in selection){
				if(selection[p]){
					result.push(p);
				}
			}
			return result;
		}
	});

	Editor.extend({
		postCreate: function () {
			var self = this;

			this.inherited(arguments);

			///增加 onDataChange、onShowEditor、onHideEditor
			this._listeners.push(rias.on(this.domNode, "dgrid-datachange", function(evt){
				return self.onDataChange(evt) != false;
			}));
			this._listeners.push(rias.on(this.domNode, "dgrid-editor-show", function(evt){
				self.onShowEditor(evt);
			}));
			this._listeners.push(rias.on(this.domNode, "dgrid-editor-hide", function(evt){
				self.onHideEditor(evt);
			}));

			this.on('.dgrid-input:focusin', function () {
				self._focusedEditorCell = self.cell(this);
			});
			this._editorFocusoutHandle = rias.on.pausable(this.domNode, '.dgrid-input:focusout', function () {
				self._focusedEditorCell = null;
			});
			this._listeners.push(this._editorFocusoutHandle);
		},
		_createEditor: function (column, object) {
			// Creates an editor instance based on column definition properties,
			// and hooks up events.
			var editor = column.editor,
				editOn = column.editOn,
				self = this,
				Widget = typeof editor !== 'string' && editor,
				args,
				cmp,
				node,
				tagName,
				tagArgs = {};

			args = column.editorArgs || {};
			if (typeof args === 'function') {
				args = args.call(this, column);
			}

			if (Widget) {
				cmp = new Widget(args);
				node = cmp.focusNode || cmp.domNode;

				// Add dgrid-input to className to make consistent with HTML inputs.
				node.className += ' dgrid-input';

				// For editOn editors, connect to onBlur rather than onChange, since
				// the latter is delayed by setTimeouts in Dijit and will fire too late.
				cmp.on(editOn ? 'blur' : 'change', function () {
					if (!cmp._dgridIgnoreChange) {
						self._updatePropertyFromEditor(column, this, {type: 'widget'});
					}
				});
			}
			else {
				// considerations for standard HTML form elements
				if (!this._hasInputListener) {
					// register one listener at the top level that receives events delegated
					this._hasInputListener = true;
					this.on('change', function (evt) {
						self._handleEditorChange(evt);
					});
					// also register a focus listener
				}

				if (editor === 'textarea') {
					tagName = 'textarea';
				}
				else {
					tagName = 'input';
					tagArgs.type = editor;
				}
				cmp = node = rias.dom.create(tagName, rias.mixin(tagArgs, {
					className: 'dgrid-input',
					name: column.field,
					tabIndex: isNaN(column.tabIndex) ? -1 : column.tabIndex
				}, args));

				if (rias.has('ie') < 9) {
					// IE<9 doesn't fire change events for all the right things,
					// and it doesn't bubble.
					var listener;
					if (editor === 'radio' || editor === 'checkbox') {
						// listen for clicks since IE doesn't fire change events properly for checks/radios
						listener = rias.on(cmp, 'click', function (evt) {
							self._handleEditorChange(evt, column);
						});
					}
					else {
						listener = rias.on(cmp, 'change', function (evt) {
							self._handleEditorChange(evt, column);
						});
					}

					if (editOn) {
						// Shared editor handlers are maintained in _editorColumnListeners, since they're not per-row
						this._editorColumnListeners.push(listener);
					}
					else if (this._editorRowListeners) {
						this._editorRowListeners[column.id] = listener;
					}
					// If editRowListeners doesn't exist and this is an always-on editor,
					// then we're here from renderCell via refreshCell, and the row should exist
					else {
						this._editorCellListeners[this.row(object).element.id][column.id] = listener;
					}
				}
			}

			if (column.autoSelect) {
				var selectNode = cmp.focusNode || cmp;
				if (selectNode.select) {
					this._listeners.push(rias.on(selectNode, 'focus', function () {
						// setTimeout is needed for always-on editors on WebKit,
						// otherwise selection is reset immediately afterwards
						setTimeout(function () {
							selectNode.select();
						}, 0);
					}));
				}
			}

			return cmp;
		},
		onDataChange: function(evt){
		},
		onShowEditor: function(evt){
		},
		onHideEditor: function(evt){
		},

		refresh: function () {
			for (var id in this._editorInstances) {
				var editorInstanceDomNode = this._editorInstances[id].domNode;
				if (editorInstanceDomNode && editorInstanceDomNode.parentNode) {
					// Remove any editor widgets from the DOM before List destroys it, to avoid issues in IE (#1100)
					editorInstanceDomNode.parentNode.removeChild(editorInstanceDomNode);
				}
			}

			/// 增加 return
			return this.inherited(arguments);
		}
	});

	Tree.extend({

		_destroyColumns: function () {
			this.inherited(arguments);
			var listeners = this._treeColumnListeners;

			for (var i = listeners.length; i--;) {
				listeners[i].remove();
			}
			this._treeColumnListeners = [];

			///begin================================///
			///需要重置，以能够重新处理（生成） treeColumn
			///reset somethings
			if(this._treeColumn){
				this._treeColumn._isConfiguredTreeColumn = undefined;
				this._treeColumn.renderCell = this._originalRenderCell;
			}
			this._originalRenderCell = undefined;
			///end=================================///

			this._treeColumn = null;
		},

		_configureTreeColumn: function (column) {
			// summary:
			//		Adds tree navigation capability to a column.
			if (column._isConfiguredTreeColumn) {
				return;
			}

			var originalRenderCell = column.renderCell || this._defaultRenderCell;
			///begin================================///
			///保存，以在 _destroyColumns 中重置
			///save the original renderCell call
			column._originalRenderCell = originalRenderCell;
			///end=================================///

			column._isConfiguredTreeColumn = true;
			column.renderCell = function (object, value, td, options) {
				// summary:
				//		Renders a cell that can be expanded, creating more rows

				var grid = this.grid,
					level = Number(options && options.queryLevel) + 1,
					mayHaveChildren = !grid.collection.mayHaveChildren || grid.collection.mayHaveChildren(object),
					expando, node;

				level = grid._currentLevel = isNaN(level) ? 0 : level;
				expando = this.renderExpando(level, mayHaveChildren,
					grid._expanded[grid.collection.getIdentity(object)], object);
				expando.level = level;
				expando.mayHaveChildren = mayHaveChildren;

				node = originalRenderCell.call(this, object, value, td, options);
				if (node && node.nodeType) {
					td.appendChild(expando);
					td.appendChild(node);
				}
				else {
					td.insertBefore(expando, td.firstChild);
				}
			};

			var clicked; // tracks row that was clicked (for expand dblclick event handling)

			this._treeColumn = column;

			var grid = this,
				colSelector = '.dgrid-content .dgrid-column-' + column.id;

			if (typeof column.renderExpando !== 'function') {
				column.renderExpando = this._defaultRenderExpando;
			}

			// Set up the event listener once and use event delegation for better memory use.
			this._treeColumnListeners.push(this.on(column.expandOn ||
				'.dgrid-expando-icon:click,' + colSelector + ':dblclick,' + colSelector + ':keydown',
				function (event) {
					var row = grid.row(event);
					if ((!grid.collection.mayHaveChildren || grid.collection.mayHaveChildren(row.data))
						&& (event.type !== 'keydown' || event.keyCode === 32)
						&& !(event.type === 'dblclick' && clicked && clicked.count > 1 && row.id === clicked.id
						&& event.target.className.indexOf('dgrid-expando-icon') > -1)) {
						clicked && clicked.count++;///FIX#1255
						grid.expand(row);
					}

					// If the expando icon was clicked, update clicked object to prevent
					// potential over-triggering on dblclick (all tested browsers but IE < 9).
					if (event.target.className.indexOf('dgrid-expando-icon') > -1) {
						if (clicked && clicked.id === grid.row(event).id) {
							clicked.count++;
						}
						else {
							clicked = {
								id: grid.row(event).id,
								count: 1
							};
						}
					}
				})
			);

			if (rias.has('touch')) {
				// Also listen on double-taps of the cell.
				this._treeColumnListeners.push(this.on(touchUtil.selector(colSelector, touchUtil.dbltap),
					function () {
						grid.expand(this);
					}));
			}

		},

		expand: function (target, expand, noTransition) {
			// summary:
			//		Expands the row corresponding to the given target.
			// target: Object
			//		Row object (or something resolvable to one) to expand/collapse.
			// expand: Boolean?
			//		If specified, designates whether to expand or collapse the row;
			//		if unspecified, toggles the current state.

			if (!this._treeColumn) {
				return;
			}

			var grid = this,
				row = target.element ? target : this.row(target),
				isExpanded = !!this._expanded[row.id],
				hasTransitionend = rias.has('transitionend'),
				promise;

			target = row.element;
			target = target.className.indexOf('dgrid-expando-icon') > -1 ? target : rias.dom.query('.dgrid-expando-icon', target)[0];

			noTransition = noTransition || !this.enableTreeTransitions;

			if (target && target.mayHaveChildren && (noTransition || expand !== isExpanded)) {
				// toggle or set expand/collapsed state based on optional 2nd argument
				var expanded = expand === undefined ? !this._expanded[row.id] : expand;

				// update the expando display
				rias.dom.replaceClass(target, 'ui-icon-triangle-1-' + (expanded ? 'se' : 'e'),
					'ui-icon-triangle-1-' + (expanded ? 'e' : 'se'));
				rias.dom.toggleClass(row.element, 'dgrid-row-expanded', expanded);

				var rowElement = row.element,
					container = rowElement.connected,
					containerStyle,
					scrollHeight,
					options = {};

				if (!container) {
					// if the children have not been created, create a container, a preload node and do the
					// query for the children
					container = options.container = rowElement.connected =
						rias.dom.create('div', { className: 'dgrid-tree-container' }, rowElement, 'after');
					var query = function (options) {
						var childCollection = grid._renderedCollection.getChildren(row.data),
							results;
						if (grid.sort && grid.sort.length > 0) {
							childCollection = childCollection.sort(grid.sort);
						}
						if (childCollection.track && grid.shouldTrackCollection) {
							container._rows = options.rows = [];

							childCollection = childCollection.track();

							// remember observation handles so they can be removed when the parent row is destroyed
							container._handles = [
								childCollection.tracking,
								grid._observeCollection(childCollection, container, options)
							];
						}
						if ('start' in options) {
							var rangeArgs = {
								start: options.start,
								end: options.start + options.count
							};
							results = childCollection.fetchRange(rangeArgs);
						} else {
							results = childCollection.fetch();
						}
						return results;
					};
					// Include level information on query for renderQuery case
					if ('level' in target) {
						query.level = target.level;
					}

					// Add the query to the promise chain
					if (this.renderQuery) {
						promise = this.renderQuery(query, options);
					}
					else {
						// If not using OnDemandList, we don't need preload nodes,
						// but we still need a beforeNode to pass to renderArray,
						// so create a temporary one
						var firstChild = rias.dom.create('div', null, container);
						promise = this._trackError(function () {
							return grid.renderQueryResults(
									query(options),
									firstChild,
									rias.mixin({ rows: options.rows },
										'level' in query ? { queryLevel: query.level } : null
									)
								).then(function (rows) {
									rias.dom.destroy(firstChild);
									return rows;
								});
						});
					}

					if (hasTransitionend) {
						// Update height whenever a collapse/expand transition ends.
						// (This handler is only registered when each child container is first created.)
						this._listeners.push(rias.on(container, hasTransitionend, this._onTreeTransitionEnd));
					}
				}

				// Show or hide all the children.

				container.hidden = !expanded;
				containerStyle = container.style;

				// make sure it is visible so we can measure it
				if (!hasTransitionend || noTransition) {
					containerStyle.display = expanded ? 'block' : 'none';
					containerStyle.height = '';
					///需要重新调整 Scroll
					this.adjustVScroll();
				}
				else {
					if (expanded) {
						containerStyle.display = 'block';
						scrollHeight = container.scrollHeight;
						containerStyle.height = '0px';
					}
					else {
						// if it will be hidden we need to be able to give a full height
						// without animating it, so it has the right starting point to animate to zero
						rias.dom.addClass(container, 'dgrid-tree-resetting');
						containerStyle.height = container.scrollHeight + 'px';
					}
					// Perform a transition for the expand or collapse.
					setTimeout(rias.hitch(this, function () {
						rias.dom.removeClass(container, 'dgrid-tree-resetting');
						containerStyle.height = expanded ? (scrollHeight ? scrollHeight + 'px' : 'auto') : '0px';
						///需要重新调整 Scroll
						this.defer(rias.hitch(this, this.adjustVScroll), 350);
					}), 0);
				}

				// Update _expanded map.
				if (expanded) {
					this._expanded[row.id] = true;
				}
				else {
					delete this._expanded[row.id];
				}
			}

			// Always return a promise
			return rias.when(promise);
		}

	});

	DnD.extend({
		postCreate: function () {
			this.inherited(arguments);

			// Make the grid's content a DnD source/target.
			var Source = this.dndConstructor || DnD.GridSource;

			var dndParams = rias.mixin(this.dndParams, {
				// add cross-reference to grid for potential use in inter-grid drop logic
				grid: this,
				dropParent: this.contentNode
			});
			if (typeof this.expand === 'function') {
				// If the Tree mixin is being used, allowNested needs to be set to true for DnD to work properly
				// with the child rows.  Without it, child rows will always move to the last child position.
				dndParams.allowNested = true;
			}
			this.dndSource = new Source(this.bodyNode, dndParams);

			// Set up select/deselect handlers to maintain references, in case selected
			// rows are scrolled out of view and unrendered, but then dragged.
			var selectedNodes = this.dndSource._selectedNodes = {};

			function selectRow(row) {
				selectedNodes[row.id] = row.element;
			}
			function deselectRow(row) {
				delete selectedNodes[row.id];
				// Re-sync dojo/dnd UI classes based on deselection
				// (unfortunately there is no good programmatic hook for this)
				rias.dom.removeClass(row.element, 'dojoDndItemSelected dojoDndItemAnchor');
			}

			this.on('dgrid-select', function (event) {
				rias.forEach(event.rows, selectRow);
			});
			this.on('dgrid-deselect', function (event) {
				rias.forEach(event.rows, deselectRow);
			});

			this.after(this, 'destroy', function () {
				delete this.dndSource._selectedNodes;
				selectedNodes = null;
				this.dndSource.destroy();
			}, true);
		}
	});

	function appendIfNode(parent, subNode) {
		if (subNode && subNode.nodeType) {
			parent.appendChild(subNode);
		}
	}
	Grid.extend({
		postMixInProperties: function(){
			///增加 this._columnStyles 。
			if(!this._columnStyles){
				this._columnStyles = {};
			}
			this.inherited(arguments);
		},
		destroy: function () {
			// Run _destroyColumns first to perform any column plugin tear-down logic.
			this._destroyColumns();
			if (this._sortListener) {
				this._sortListener.remove();
			}
			///增加 this._columnStyles 。
			for (var name in this._columnStyles) {
				this._columnStyles[name].remove();
			}

			this.inherited(arguments);
		},
		postCreate: function () {
			var self = this;

			this.inherited(arguments);

			///增加 onSort，貌似没起作用
			this._listeners.push(rias.on(this.domNode, "dgrid-sort", function(evt){
				self.onSort(evt);
			}));
		},
		onSort: function(evt){
		},
		styleColumn: function (colId, css, /*String*/parentCss) {
			///增加 this._columnStyles
			parentCss = parentCss || "";
			var sId = colId + parentCss,
				rule = this._columnStyles[sId];
			if (rule) {
				rule.set(css);
			}else{
				rule = this.addCssRule('#' + miscUtil.escapeCssIdentifier(this.domNode.id) + " " + parentCss + ' .dgrid-column-' + miscUtil.escapeCssIdentifier(colId, '-'), css);
				this._columnStyles[sId] = rule;
			}
			return rule;
		},
		_configColumn: function (column, rowColumns, prefix) {
			var style = {},
				b;
			///增加 cell 的 style
			if(column.style){
				rias.mixinDeep(style, rias.dom.styleToObject(column.style));
				b = 1;
			}
			if(column.align){
				style["text-align"] = column.align;
				b = 1;
			}
			if(b){
				this.styleColumn(column.id, style, " .dgrid-content");
				this.styleColumn(column.id, style, " .dgrid-footer-summary-row");
			}
			this.inherited(arguments);
		},
		_defaultRenderCell: function (object, value, td) {
			if (this.formatter) {
				// Support formatter, with or without formatterScope
				var formatter = this.formatter,
					formatterScope = this.grid.formatterScope;
				/// 增加 try..catch
				try{
					td.innerHTML = typeof formatter === 'string' && formatterScope ?
						formatterScope[formatter](value, object) : this.formatter(value, object);
				}catch(e){
					console.error(rias.captureStackTrace(e));
					td.appendChild(rias.dom.doc.createTextNode(value));
				}
			}
			else if (value != null) {
				td.appendChild(rias.dom.doc.createTextNode(value));
			}
		},
		/*_createBodyRowCell: function (cellElement, column, item, options) {
			var cellData = item;

			// Support get function or field property (similar to DataGrid)
			if (column.get) {
				cellData = column.get(item);
			}else if ('field' in column && column.field !== '_item') {
				cellData = item[column.field];
			}

			if (column.renderCell) {
				// A column can provide a renderCell method to do its own DOM manipulation,
				// event handling, etc.
				appendIfNode(cellElement, column.renderCell(item, cellData, cellElement, options));
			}else {
				this._defaultRenderCell.call(column, item, cellData, cellElement, options);
			}
		},*/
		/*_createHeaderRowCell: function (cellElement, column) {
			var contentNode = column.headerNode = cellElement;
			var field = column.field;
			if(column._riasrRowNumColumn){
				this._riasrRowNumColumn = column;
			}else if(column._riasrOpColumn){
				this._riasrOpColumn = column;
			}else if(column._riasrSelectorColumn){
				this._riasrSelectorColumn = column;
			}
			if (field) {
				cellElement.field = field;
			}
			// allow for custom header content manipulation
			if (column.renderHeaderCell) {
				appendIfNode(contentNode, column.renderHeaderCell(contentNode));
			}
			else if ('label' in column || column.field) {
				contentNode.appendChild(document.createTextNode('label' in column ? column.label : column.field));
			}
			if (column.sortable !== false && field && field !== '_item') {
				cellElement.sortable = true;
				cellElement.className += ' dgrid-sortable';
			}
		},*/

		resize: function (changeSize, resultSize) {
			var box = this.inherited(arguments);
			if(box){
				// extension of List.resize to allow accounting for
				// column sizes larger than actual grid area
				var headerTableNode = this.headerNode.firstChild,
					contentNode = this.contentNode,
					width;
				// Force contentNode width to match up with header width.
				contentNode.style.width = ''; // reset first
				if (contentNode && headerTableNode) {
					if ((width = headerTableNode.offsetWidth) > contentNode.offsetWidth) {
						// update size of content node if necessary (to match size of rows)
						// (if headerTableNode can't be found, there isn't much we can do)
						contentNode.style.width = width + 'px';
					}
				}
			}
			return box;
		}
	});

	return Grid;

});